{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bloqade-Shuttle","text":"<p>Bloqade-shuttle is an SDK for simulation and programming neutral atom quantum computers at the level of atom layout and  shuttling.</p> <p>The project aims to establish eDSL for programming and optimizing atom layout and shuttling operations on neutral atom quantum computers. Our goal is to provide a framework for anyone to use with neutral atom quantum technology.</p> <p>We welcome industry and academic partners to collaborate to develop Bloqade-shuttle to further advance neutral atom technology and its applications to quantum computing.</p> <p>If you are interested in guiding future development of this project, consider becoming a member of our open source steering committee!  We also welcome contributions via pull requests, bug reports, or feature requests.</p>"},{"location":"#installation","title":"Installation","text":"<p><pre><code>uv add bloqade-shuttle\n</code></pre> &lt;! TODO: update links to point to documentation website once available. &gt; See Installation for more details.</p> <p>Check out new Blog to understand more about tools and shuttle.</p>"},{"location":"#other-useful-links","title":"Other useful links","text":"<ul> <li>Bloqade Geometry a related project that provides components for defining and manipulating geometric objects in Bloqade Shuttle.</li> </ul>"},{"location":"#stability","title":"Stability","text":"<p>Bloqade-Shuttle is currently in active development, while we are gathering feedback from early users and refining the language design. We can work with our partners to provide support for transitioning to the new language as well as ongoing maintenance and updates.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contains pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for mangaging command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"install/","title":"Installation","text":"<p>Bloqade Shuttle is available on pypi registry. Shuttle supports Python 3.10 or later. We recommend using Python 3.10+ for the best experience.</p> <p>We strongly recommend developing project using <code>uv</code>, which is the official development environment for Kirin and Bloqade Shuttle. You can install <code>uv</code> using the following command:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre>"},{"location":"install/#install-package","title":"Install package:","text":"<pre><code>uv add bloqade-shuttle\n</code></pre>"},{"location":"install/#development","title":"Development","text":"<p>We use <code>uv</code> to manage the development environment, after you install <code>uv</code>, you can install the development dependencies using the following command:</p> <pre><code>uv sync\n</code></pre> <p>Our code review requires that you pass the tests and the linting checks. We recommend you to install <code>pre-commit</code> to run the checks before you commit your changes, the command line tool <code>pre-commit</code> has been installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/08/04/programming-moves-for-logical-magic-state-distillation/","title":"Programming Moves for Logical Magic State Distillation","text":"<p>Download script here.</p> <p>In this example, we program the move layout employed in the demonstration of logical magic state distillation for a distance-5 color code, as presented in QuEra\u2019s recent publication: \u201cExperimental demonstration of logical magic state distillation\u201d, Nature, 2025. This example focuses specifically on the atom moves and two-qubit gate operations between atom pairs. For clarity, we omit the single-qubit gates used in the full circuit. The circuits executed in the paper were carefully optimized for the architectural features of QuEra\u2019s neutral atom hardware. In particular, they leverage extensive parallelization of atom shuttling operations and simultaneous execution of two-qubit gates.</p> <p>We will demonstrate that <code>bloqade.shuttle</code> provides a concise and efficient interface for expressing such parallelized atom movements.</p> <p>As a first step, we import the relevant modules of <code>bloqade.shuttle</code> and <code>kirin</code>.</p> <pre><code>from typing import Any, TypeVar\n\nimport matplotlib\nfrom bloqade.geometry.dialects import grid\nfrom kirin.dialects import ilist\n\nfrom bloqade.shuttle import gate, init, spec\nfrom bloqade.shuttle.prelude import move\nfrom bloqade.shuttle.stdlib.spec import single_zone_spec\nfrom bloqade.shuttle.stdlib.waypoints import move_by_waypoints\nfrom bloqade.shuttle.visualizer import PathVisualizer\n</code></pre> <p>The primary subroutines used to implement atom transport are the <code>move</code> dialect and the <code>move_by_waypoints</code> function from the standard library. Programming atom movement in shuttle is centered around atoms arranged on two-dimensional grids. This reflects the capabilities of QuEra\u2019s Gemini-class hardware, which utilizes pairs of acousto-optic deflectors (AODs) to manipulate atom positions independently in the x- and y-directions.</p> <p>Grid-based layouts are chosen to optimize both the accessibility and parallelizability of atom moves, given AOD constraints such as simultaneous pickup of atoms aligned along columns and rows, as well as the need to prevent inter-atomic collisions during transport. The shuttle framework encodes AOD constraints directly into the semantics of move kernel objects. Attempting to compile or execute a move sequence that violates these constraints will result in a runtime or compile-time error, ensuring physical feasibility of the programmed layout on hardware</p> <p>As a first step, we define three global parameters that govern the geometry and dynamics of the atom array:</p> <ul> <li> <p><code>grid_spacing</code>: Specifies the lattice spacing of the initial two-dimensional grid. This grid corresponds to the static trap array defined by the spatial light modulator (SLM), which generates the optical tweezers used to hold the atoms.</p> </li> <li> <p><code>entangling_pair_dist</code>: Sets the target distance between pairs of atoms that are intended to undergo a two-qubit entangling gate. This distance must be sufficiently small to enable a strong Rydberg-mediated interaction, which is essential for high-fidelity entanglement. A typical value used in experiments is 2 \u03bcm.</p> </li> <li> <p><code>path_shift_dist</code>: During atom transport, it is often necessary to temporarily displace atoms off-grid to avoid collisions when crossing rows or columns. This parameter defines the offset applied to atoms during their movement, enabling collision-free shuttling through the array.</p> </li> </ul> <p>As a first step we define the global geometry choices.</p> <pre><code>grid_spacing = 10.0  # (1)!\n\nentangling_pair_dist = 2.0  # (2)!\n\npath_shift_dist = (\n    3.0  # (3)!\n)\n</code></pre> <ol> <li>spacing of the grid traps</li> <li>distance between atom pairs getting entangled</li> <li>distance that is used to shift the atom path out of the columns or rows</li> </ol>"},{"location":"blog/2025/08/04/programming-moves-for-logical-magic-state-distillation/#basic-move-pattern","title":"Basic move pattern","text":"<p>In this section, we program the precise atom movement pattern used in the experimental demonstration of logical magic state distillation. Due to the high degree of connectivity required by the circuit, atom transport is restricted to full-row and full-column movements, maximizing parallelism while respecting hardware constraints.</p> <p>We begin by specifying the initial atom grid configuration. This example focuses on a single entangling zone layout, where each logical qubit is encoded along a single row of atoms. For a distance-5 color code, each logical qubit comprises 17 physical qubits. The experimental implementation involved five such logical qubits.</p> <p>This geometry is conveniently defined using the <code>single_zone_spec</code> function, where:</p> <ul> <li><code>num_x</code> specifies the number of columns (i.e., physical qubits per logical qubit),</li> <li><code>num_y</code> specifies the number of rows (i.e., logical qubits), and</li> <li><code>spacing</code> defines the uniform distance between adjacent rows and columns.</li> </ul> <p>By construction, the grid is assumed to be equidistant in both spatial dimensions.</p> <pre><code>arch_spec = single_zone_spec(num_x=17, num_y=5, spacing=grid_spacing)\n</code></pre> <p>We define a set of helper kernel functions to enable coordinated movement of atoms along rows and columns of the grid. The core routine, <code>entangle_cols</code>, operates on two <code>IList</code> arguments -- <code>ctrls</code> and <code>qargs</code>. The <code>ctrls</code> list specifies the row indices of control qubits to be moved, while <code>qargs</code> indicates the row indices of the target qubits with which entanglement is to be performed.</p> <p>To register the function as a valid movement kernel for compilation to <code>bloqade.shuttle</code> IR, we decorate it with <code>@move</code>. This ensures compatibility with <code>kirin</code>\u2019s intermediate representation and hardware-aware compilation pipeline.</p> <p>The structure of the entangling routine comprises the following key steps:</p> <ol> <li> <p>Define initial trap sites: Specify the locations of static SLM-defined traps where all qubits are initially held.</p> </li> <li> <p>Construct subgrids: Define subgrids corresponding to the atoms to be picked up (<code>ctrls</code>), and subgrids defining the positions of the target qubits (<code>qargs</code>) near which the control atoms will be temporarily positioned to enable interaction.</p> </li> <li> <p>Specify waypoint trajectories: Construct ordered sequences of intermediate positions (waypoints) to guide atom transport between subgrids.</p> </li> <li> <p>Invoke <code>move_by_waypoints</code>: Use this function to concatenate the defined path segments, producing the full motion trajectory between initial and final subgrid configurations.</p> </li> </ol> <p>It is important to note that, in this layout, atoms always return to their original static trap positions following each entangling operation. This symmetry enables easy definition of the reverse path by simply inverting the sequence of waypoints.</p> <p>The <code>move_by_waypoints</code> function includes Boolean flags that indicate whether atoms should be picked up from or dropped into static traps at each stage. In the context of this circuit, we maintain atoms within the AODs during gate execution and only return them to their SLM-defined traps afterward. This is a deliberate design choice and not a general constraint. More sophisticated pickup/dropoff sequences can be constructed using multiple defined trap grids. However, care must be taken: dropping an atom at a site lacking an active trap will result in atom loss.</p> <pre><code>@move\ndef entangle_cols(ctrls: ilist.IList[int, Any], qargs: ilist.IList[int, Any]): # (1)!\n\n    # set up zone layout\n    zone = spec.get_static_trap(zone_id=\"traps\") # (2)!\n    traps_shape = grid.shape(zone) # (3)!\n    all_rows = ilist.range(traps_shape[1]) # (4)!\n\n    src = grid.sub_grid(zone, ctrls, all_rows) # (5)!\n    dst = grid.sub_grid(zone, qargs, all_rows) # (6)!\n\n    # define the moves\n    first_waypoint = grid.shift(src, 0.0, -path_shift_dist) # (7)!\n    second_waypoint = grid.shift(dst, -entangling_pair_dist, -path_shift_dist) # (8)!\n    third_waypoint = grid.shift(dst, -entangling_pair_dist, 0.0) # (9)!\n\n    waypoints = ilist.IList([src, first_waypoint, second_waypoint, third_waypoint]) # (10)!\n\n    reverse_waypoints = ilist.IList(\n        [third_waypoint, second_waypoint, first_waypoint, src]\n    ) # (11)!\n\n    move_by_waypoints(waypoints, True, False) # (12)!\n    gate.top_hat_cz(zone) # (13)!\n    move_by_waypoints(reverse_waypoints, False, True) # (14)!\n</code></pre> <ol> <li>kernel function to entangle columns of atoms. <code>ctrls</code>...subgrid of atoms to be picked up, <code>qargs</code>...subgrid of atoms the ctrl qubits will get entangled with</li> <li>fill the defined zone specification with traps</li> <li>get the shape of the trap array</li> <li>generate an ilist from 0 to the number of rows in the trap array</li> <li>subgrid of control qubits that are picked up</li> <li>subgrid of target qubits that are entangled with the control qubits</li> <li>shifting the src grid down along the y-axis</li> <li>shift the moving cols to the respective x-positions of the target qubits and add an offset in the x-direction</li> <li>shift the moving cols back up into the original y-position to form atom pairs that will get a gate</li> <li>combine the waypoints into an ilist</li> <li>the reverse waypoints defining the reverse path back to the original positions</li> <li>move the qubits along the waypoints, True means that the atoms are picked up and False means that they are not dropped at the end of the move</li> <li>apply the entangling gate to the atoms that are now in the right positions (paired up)</li> <li>move the atoms back to their original positions, False means that the atoms are not picked up (since they are still in the AOD) and True means that they are dropped back into their static trap site at the end of the move</li> </ol> <p>In an analogous manner, we can now define parallel transport operations for atoms along rows of the grid.</p> <pre><code>@move\ndef entangle_rows(ctrls: ilist.IList[int, Any], qargs: ilist.IList[int, Any]): # (1)!\n\n    # set up zone layout\n    zone = spec.get_static_trap(zone_id=\"traps\") # (2)!\n    traps_shape = grid.shape(zone) # (3)!\n    all_cols = ilist.range(traps_shape[0]) # (4)!\n\n    src = grid.sub_grid(zone, all_cols, ctrls)\n    dst = grid.sub_grid(zone, all_cols, qargs)\n\n    # define the moves\n    first_waypoint = grid.shift(src, entangling_pair_dist, 0.0) # (5)!\n    second_waypoint = grid.shift(dst, entangling_pair_dist, 0.0) # (6)!\n\n    waypoints = ilist.IList([src, first_waypoint, second_waypoint]) # (7)!\n    reverse_waypoints = ilist.IList([second_waypoint, first_waypoint, src]) # (8)!\n\n    move_by_waypoints(waypoints, True, False) # (9)!\n    gate.top_hat_cz(zone) # (10)!\n    move_by_waypoints(reverse_waypoints, False, True) # (11)!\n</code></pre> <ol> <li>kernel function to entangle rows of atoms. <code>ctrls</code>...subgrid of atoms to be picked up, <code>qargs</code>...subgrid of atoms the ctrl qubits will get entangled with</li> <li>get the positions of the static traps in the entangling zone</li> <li>get the shape of the trap array</li> <li>generate an ilist from 0 to the number of columns in the trap array</li> <li>shift the src grid to the right along the x-axis</li> <li>move the src grid to the y-positions of the target qubits</li> <li>combine the waypoints into an ilist</li> <li>the reverse waypoints defining the reverse path back to the original positions</li> <li>move the qubits along the waypoints, True means that the atoms are picked up and False means that they are not dropped at the end of the move</li> <li>apply the entangling gate to the atoms that are now in the right positions (paired up)</li> <li>move the atoms back to their original positions, False means that the atoms are not picked up (since they are still in the AOD) and True means that they are dropped back into their static trap site at the end of the move</li> </ol> <p>Using these helper functions, we can now specify the complete move pattern in just a few lines of code by providing the control and target atom indices to the <code>entangle_cols</code> and <code>entangle_rows</code> functions.</p> <p>As before, we define this as a kernel function, annotated with the <code>@move</code> decorator to indicate compatibility with the bloqade.shuttle IR. This kernel is wrapped inside a closure and returned as a first-class move kernel function.</p> <pre><code>def make_main(entangle_cols, entangle_rows): # (1)!\n\n    @move\n    def main(): # (2)!\n\n        init.fill([spec.get_static_trap(zone_id=\"traps\")])\n\n        # encode logical qubits by entangling pairs of atoms in columns\n        entangle_cols([1, 10, 12, 13], [3, 7, 14, 16])\n        entangle_cols([4, 8, 11, 15], [7, 10, 14, 16])\n        entangle_cols([2, 8, 9, 10, 14], [4, 6, 7, 13, 16])\n        entangle_cols([0, 3, 5, 10, 11], [2, 6, 8, 12, 13])\n        entangle_cols([0, 2, 4, 6, 8, 12], [1, 3, 5, 7, 9, 15])\n\n        # logical qubit operations by moving entire rows of atoms\n        entangle_rows([0, 2], [1, 3])\n        entangle_rows([1, 3], [2, 4])\n        entangle_rows([3, 4], [0, 1])\n\n    return main\n\n\nker = make_main(entangle_cols, entangle_rows)\n</code></pre> <ol> <li>Helper function to create the main move kernel for logical magic state distillation. <code>entangle_cols</code>: Function to entangle columns of atoms. <code>entangle_rows</code>: Function to entangle rows of atoms. Returns <code>main</code>: The main move kernel function that defines the entire move pattern.</li> <li>Main move kernel function that defines the entire move pattern for the logical magic state distillation experiment.</li> </ol> <p>We can verify the correctness of the programmed move layout using the <code>PathVisualizer</code> utility provided by <code>bloqade.shuttle</code>. This tool displays the atom trajectories between defined waypoints and enables stepwise inspection of the full movement sequence via the <code>Continue</code> button. Red flashes are used to indicate the application of two-qubit gate pulses at the entangling zone during the sequence.</p> <pre><code>matplotlib.use(\"TkAgg\")  # (1)!\n\nPathVisualizer(ker.dialects, arch_spec=arch_spec).run(ker, ())\n</code></pre> <ol> <li>requirement for PathVisualizer</li> </ol>"},{"location":"blog/2025/08/04/programming-moves-for-logical-magic-state-distillation/#further-refining-the-move-pattern","title":"Further refining the move pattern","text":"<p>We now take a further step by introducing a slight optimization to the move pattern. In the previous example, control qubits were moved in both leftward and rightward directions, but ultimately all were positioned to the left of their respective target qubits. This introduces unnecessary displacement for half of the control atoms. To minimize total movement, we can instead position control atoms to the nearest side of the target qubits, i.e., those moving rightward are placed to the left, and those moving leftward are placed to the right of the targets.</p> <p>To implement this, we define an additional helper function that computes the nearest feasible final position for each control qubit, given the target layout and movement direction.</p> <pre><code>N = TypeVar(\"N\")\n\n\n@move\ndef get_final_positions(\n    src: ilist.IList[float, N], dst: ilist.IList[float, N], offset: float\n): # (1)!\n\n    assert len(src) == len(\n        dst\n    ), \"Source and destination lists must be of the same length.\"\n\n    def get_last_pos(i: int) -&gt; float:\n        assert src[i] != dst[i], \"Source and destination positions must not be equal.\"\n        if src[i] &lt; dst[i]:\n            return dst[i] - offset\n        elif src[i] &gt; dst[i]:\n            return dst[i] + offset\n        else:\n            return dst[i]\n\n    return ilist.map(get_last_pos, ilist.range(len(src)))\n</code></pre> <ol> <li>Helper function to compute the nearest final positions for entanglement.</li> </ol> <p>Using this helper function, we can now construct new waypoint sequences that incorporate the nearest final positions for the control qubits.</p> <pre><code>@move\ndef entangle_cols_low_dist(ctrls: ilist.IList[int, Any], qargs: ilist.IList[int, Any]): # (1)!\n\n    zone = spec.get_static_trap(zone_id=\"traps\")\n    traps_shape = grid.shape(zone)\n    all_rows = ilist.range(traps_shape[1])\n\n    src = grid.sub_grid(zone, ctrls, all_rows)\n    dst = grid.sub_grid(zone, qargs, all_rows)\n\n    first_waypoint = grid.shift(src, 0.0, -path_shift_dist)\n\n    dst_x = grid.get_xpos(dst)\n    src_x = grid.get_xpos(src)\n\n    last_x = get_final_positions(\n        src_x, dst_x, entangling_pair_dist\n    )  # (2)!\n\n    second_pos = grid.from_positions(last_x, grid.get_ypos(first_waypoint))\n    last_pos = grid.from_positions(last_x, grid.get_ypos(dst))\n\n    waypoints = ilist.IList([src, first_waypoint, second_pos, last_pos])\n    reverse_waypoints = ilist.IList([last_pos, second_pos, first_waypoint, src])\n\n    move_by_waypoints(waypoints, True, False)\n    gate.top_hat_cz(zone)\n    move_by_waypoints(reverse_waypoints, False, True)\n</code></pre> <ol> <li>Helper function to entangle columns of atoms on a grid in a single entangling zone with optimized final positions (nearest location). <code>ctrls</code>...subgrid of atoms to be picked up, <code>qargs</code>...subgrid of atoms the ctrl qubits will get entangled with</li> <li>get the nearest final positions for the control qubits</li> </ol> <p>We can now define a new move kernel that implements the optimized column-wise transport pattern using the updated waypoint assignments.</p> <pre><code>ker = make_main(entangle_cols_low_dist, entangle_rows)\n</code></pre> <p>Finally, we can once again visualize the optimized move pattern using the PathVisualizer to inspect the resulting trajectories and validate the updated layout.</p> <pre><code>matplotlib.use(\"TkAgg\") # (1)!\n\nPathVisualizer(ker.dialects, arch_spec=arch_spec).run(ker, ())\n</code></pre> <ol> <li>requirement for PathVisualizer</li> </ol>"},{"location":"reference/bloqade/shuttle/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/arch/","title":"Arch","text":""},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.ArchSpecInterpreter","title":"ArchSpecInterpreter  <code>dataclass</code>","text":"<pre><code>ArchSpecInterpreter(arch_spec: ArchSpec)\n</code></pre> <p>               Bases: <code>ArchSpecMixin</code>, <code>Interpreter</code></p> <p>Interpreter that requires an architecture specification.</p>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.ArchSpecMixin","title":"ArchSpecMixin  <code>dataclass</code>","text":"<pre><code>ArchSpecMixin(arch_spec: ArchSpec)\n</code></pre> <p>Base class for interpreters that require an architecture specification.</p>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout","title":"Layout  <code>dataclass</code>","text":"<pre><code>Layout(\n    static_traps: dict[str, Grid],\n    fillable: set[str],\n    has_cz: set[str],\n    has_local: set[str],\n    *,\n    special_grid: dict[str, Grid] = dict()\n)\n</code></pre>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout.fillable","title":"fillable  <code>instance-attribute</code>","text":"<pre><code>fillable: set[str]\n</code></pre> <p>The set of trap names that are fillable by the sorter.</p>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout.has_cz","title":"has_cz  <code>instance-attribute</code>","text":"<pre><code>has_cz: set[str]\n</code></pre> <p>The set of trap names that can have a CZ gates applied.</p>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout.has_local","title":"has_local  <code>instance-attribute</code>","text":"<pre><code>has_local: set[str]\n</code></pre> <p>The set of trap names that can have local single qubit gates applied.</p>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout.special_grid","title":"special_grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>special_grid: dict[str, Grid] = field(\n    default_factory=dict, kw_only=True\n)\n</code></pre> <p>Set of special grid values that are not static traps, but can be used for specific purposes.</p>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout.static_traps","title":"static_traps  <code>instance-attribute</code>","text":"<pre><code>static_traps: dict[str, Grid]\n</code></pre> <p>Abstract base class for layout.</p>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout.bounding_box","title":"bounding_box","text":"<pre><code>bounding_box() -&gt; tuple[float, float, float, float]\n</code></pre> <p>Get the bounding box (xmin, xmax, ymin, ymax) of the layout.</p> Source code in <code>src/bloqade/shuttle/arch.py</code> <pre><code>def bounding_box(self) -&gt; tuple[float, float, float, float]:\n    \"\"\"Get the bounding box (xmin, xmax, ymin, ymax) of the layout.\"\"\"\n    xmin = float(\"inf\")\n    xmax = float(\"-inf\")\n    ymin = float(\"inf\")\n    ymax = float(\"-inf\")\n\n    for zone in chain(self.static_traps.values(), self.special_grid.values()):\n        if zone.x_init is not None:\n            xmin = min(xmin, zone.x_init)\n            xmax = max(xmax, zone.x_init + zone.width)\n        if zone.y_init is not None:\n            ymin = min(ymin, zone.y_init)\n            ymax = max(ymax, zone.y_init + zone.height)\n\n    if (\n        xmin == float(\"inf\")\n        or xmax == float(\"-inf\")\n        or ymin == float(\"inf\")\n        or ymax == float(\"-inf\")\n    ):\n        raise ValueError(\"Layout has incomplete bounding box data.\")\n\n    return xmin, xmax, ymin, ymax\n</code></pre>"},{"location":"reference/bloqade/shuttle/arch/#bloqade.shuttle.arch.Layout.get_zone_id","title":"get_zone_id","text":"<pre><code>get_zone_id(zone: Grid) -&gt; str | None\n</code></pre> <p>Get the zone ID for a given grid, if it exists in static_traps or special_grid.</p> Source code in <code>src/bloqade/shuttle/arch.py</code> <pre><code>def get_zone_id(self, zone: Grid) -&gt; str | None:\n    \"\"\"Get the zone ID for a given grid, if it exists in static_traps or special_grid.\"\"\"\n    return self._zone_to_id.get(zone, None)\n</code></pre>"},{"location":"reference/bloqade/shuttle/prelude/","title":"Kernel decorator","text":""},{"location":"reference/bloqade/shuttle/analysis/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/analysis/runtime/","title":"Runtime","text":""},{"location":"reference/bloqade/shuttle/analysis/runtime/#bloqade.shuttle.analysis.runtime.RuntimeAnalysis","title":"RuntimeAnalysis","text":"<p>               Bases: <code>ForwardExtra[RuntimeFrame, EmptyLattice]</code></p> <p>Forward dataflow analysis to check if a method has quantum runtime.</p> <p>This analysis checks if a method contains any quantum runtime operations. It is used to determine if the method can be executed on a quantum device.</p>"},{"location":"reference/bloqade/shuttle/analysis/runtime/#bloqade.shuttle.analysis.runtime.RuntimeAnalysis.has_quantum_runtime","title":"has_quantum_runtime","text":"<pre><code>has_quantum_runtime(method: Method) -&gt; bool\n</code></pre> <p>Return True if the method has quantum runtime operations, False otherwise.</p> Source code in <code>src/bloqade/shuttle/analysis/runtime.py</code> <pre><code>def has_quantum_runtime(self, method: ir.Method) -&gt; bool:\n    \"\"\"Return True if the method has quantum runtime operations, False otherwise.\"\"\"\n    frame, _ = self.run_analysis(method)\n    return frame.is_quantum\n</code></pre>"},{"location":"reference/bloqade/shuttle/analysis/runtime/#bloqade.shuttle.analysis.runtime.RuntimeFrame","title":"RuntimeFrame  <code>dataclass</code>","text":"<pre><code>RuntimeFrame(\n    quantum_stmts: set[Statement] = set(),\n    is_quantum: bool = False,\n)\n</code></pre> <p>               Bases: <code>ForwardFrame[EmptyLattice]</code></p> <p>Frame for quantum runtime analysis. This frame is used to track the state of quantum operations within a method.</p>"},{"location":"reference/bloqade/shuttle/analysis/runtime/#bloqade.shuttle.analysis.runtime.RuntimeFrame.is_quantum","title":"is_quantum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_quantum: bool = False\n</code></pre> <p>Whether the frame contains quantum operations.</p>"},{"location":"reference/bloqade/shuttle/analysis/runtime/#bloqade.shuttle.analysis.runtime.RuntimeFrame.quantum_stmts","title":"quantum_stmts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantum_stmts: set[Statement] = field(default_factory=set)\n</code></pre> <p>Set of quantum statements in the frame.</p>"},{"location":"reference/bloqade/shuttle/analysis/zone/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/analysis/zone/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade/shuttle/analysis/zone/analysis/#bloqade.shuttle.analysis.zone.analysis.ZoneAnalysis","title":"ZoneAnalysis  <code>dataclass</code>","text":"<pre><code>ZoneAnalysis(arch_spec: ArchSpec = ArchSpec())\n</code></pre> <p>               Bases: <code>Forward[Zone]</code></p> <p>Analysis for zones in the Qourier context. This analysis extends the Forward analysis to work with Zone types.</p>"},{"location":"reference/bloqade/shuttle/analysis/zone/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade/shuttle/analysis/zone/impl/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/analysis/zone/impl/grid/","title":"Grid","text":""},{"location":"reference/bloqade/shuttle/analysis/zone/impl/py/","title":"Py","text":""},{"location":"reference/bloqade/shuttle/analysis/zone/impl/spec/","title":"Spec","text":""},{"location":"reference/bloqade/shuttle/codegen/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/codegen/taskgen/","title":"Taskgen","text":""},{"location":"reference/bloqade/shuttle/dialects/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/action/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/action/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/action/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/action/_interface/#bloqade.shuttle.dialects.action._interface.move","title":"move","text":"<pre><code>move(grid: Grid[Nx, Ny]) -&gt; None\n</code></pre> <p>Move the aod from its current location to the given location.</p> Source code in <code>src/bloqade/shuttle/dialects/action/_interface.py</code> <pre><code>@_wraps(Move)\ndef move(grid: Grid[Nx, Ny]) -&gt; None:\n    \"\"\"Move the aod from its current location to the given location.\"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/action/_interface/#bloqade.shuttle.dialects.action._interface.set_loc","title":"set_loc","text":"<pre><code>set_loc(grid: Grid[Nx, Ny]) -&gt; None\n</code></pre> <p>Set the location of the aod using a grid.</p> Source code in <code>src/bloqade/shuttle/dialects/action/_interface.py</code> <pre><code>@_wraps(Set)\ndef set_loc(grid: Grid[Nx, Ny]) -&gt; None:\n    \"\"\"Set the location of the aod using a grid.\"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/action/_interface/#bloqade.shuttle.dialects.action._interface.turn_off","title":"turn_off","text":"<pre><code>turn_off(x_tones: slice, y_tones: slice) -&gt; None\n</code></pre><pre><code>turn_off(\n    x_tones: slice, y_tones: IList[int, Any] | list[int]\n) -&gt; None\n</code></pre><pre><code>turn_off(\n    x_tones: IList[int, Any] | list[int], y_tones: slice\n) -&gt; None\n</code></pre><pre><code>turn_off(\n    x_tones: IList[int, Any] | list[int],\n    y_tones: IList[int, Any] | list[int],\n) -&gt; None\n</code></pre> <pre><code>turn_off(x_tones, y_tones)\n</code></pre> <p>Turn on tones at the given x and y locations.</p> Source code in <code>src/bloqade/shuttle/dialects/action/_interface.py</code> <pre><code>@_wraps(TurnOff)\ndef turn_off(x_tones, y_tones):\n    \"\"\"Turn on tones at the given x and y locations.\"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/action/_interface/#bloqade.shuttle.dialects.action._interface.turn_on","title":"turn_on","text":"<pre><code>turn_on(x_tones: slice, y_tones: slice) -&gt; None\n</code></pre><pre><code>turn_on(\n    x_tones: slice, y_tones: IList[int, Any] | list[int]\n) -&gt; None\n</code></pre><pre><code>turn_on(\n    x_tones: IList[int, Any] | list[int], y_tones: slice\n) -&gt; None\n</code></pre><pre><code>turn_on(\n    x_tones: IList[int, Any] | list[int],\n    y_tones: IList[int, Any] | list[int],\n) -&gt; None\n</code></pre> <pre><code>turn_on(x_tones, y_tones)\n</code></pre> <p>Turn on tones at the given x and y locations.</p> Source code in <code>src/bloqade/shuttle/dialects/action/_interface.py</code> <pre><code>@_wraps(TurnOn)\ndef turn_on(x_tones, y_tones):\n    \"\"\"Turn on tones at the given x and y locations.\"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/action/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/atom/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/atom/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/atom/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/atom/_interface/#bloqade.shuttle.dialects.atom._interface.measure","title":"measure","text":"<pre><code>measure(\n    atoms: list[Atom], qubits: list[Qubit]\n) -&gt; ilist.IList[int, Any]\n</code></pre><pre><code>measure(\n    atoms: IList[Atom, NumAtoms], qubits: list[Qubit]\n) -&gt; ilist.IList[int, NumAtoms]\n</code></pre><pre><code>measure(\n    atoms: list[Atom], qubits: IList[Qubit, NumAtoms]\n) -&gt; ilist.IList[int, NumAtoms]\n</code></pre><pre><code>measure(\n    atoms: IList[Atom, NumAtoms],\n    qubits: IList[Qubit, NumAtoms],\n) -&gt; ilist.IList[int, NumAtoms]\n</code></pre> <pre><code>measure(atoms, qubits) -&gt; ilist.IList[int, Any]\n</code></pre> <p>Perform a destructive measurement on the specified atoms.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>list[Atom] | IList[Atom, NumAtoms]</code> <p>The atoms to be measured.</p> required <code>qubits</code> <code>list[Qubit] | IList[Qubit, NumAtoms]</code> <p>The qubits associated with the atoms being measured.</p> required <p>Returns:</p> Type Description <code>IList[int, Any]</code> <p>ilist.IList[int, NumAtoms | Any]: A list of measurement results, where each result corresponds to an atom.</p> Source code in <code>src/bloqade/shuttle/dialects/atom/_interface.py</code> <pre><code>@_wraps(Measure)\ndef measure(atoms, qubits) -&gt; ilist.IList[int, Any]:\n    \"\"\"\n    Perform a destructive measurement on the specified atoms.\n\n    Args:\n        atoms (list[Atom] | ilist.IList[Atom, NumAtoms]): The atoms to be measured.\n        qubits (list[Qubit] | ilist.IList[Qubit, NumAtoms]): The qubits associated with the atoms being measured.\n\n    Returns:\n        ilist.IList[int, NumAtoms | Any]: A list of measurement results, where each result corresponds to an atom.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/atom/_interface/#bloqade.shuttle.dialects.atom._interface.move","title":"move","text":"<pre><code>move(\n    zone: Grid, atoms: list[Atom]\n) -&gt; ilist.IList[Atom, Any]\n</code></pre><pre><code>move(\n    zone: Grid, atoms: IList[Atom, NumAtoms]\n) -&gt; ilist.IList[Atom, NumAtoms]\n</code></pre> <pre><code>move(zone, atoms) -&gt; ilist.IList[Atom, Any]\n</code></pre> <p>Create new atoms in the specified zone with the given qubits. Note that the specific locations of the atoms will be determined by the compiler.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Grid</code> <p>The grid zone where to move the atoms.</p> required <code>atoms</code> <code>list[Atom] | IList[Atom, NumQubits]</code> <p>The atoms to be moved.</p> required <p>Returns:</p> Type Description <code>IList[Atom, Any]</code> <p>ilist.IList[Atom, NumQubits | Any]: A list of newly created atoms.</p> Source code in <code>src/bloqade/shuttle/dialects/atom/_interface.py</code> <pre><code>@_wraps(Move)\ndef move(zone, atoms) -&gt; ilist.IList[Atom, Any]:\n    \"\"\"\n    Create new atoms in the specified zone with the given qubits. Note that the specific locations of the atoms will be determined by the compiler.\n\n\n    Args:\n        zone (grid.Grid): The grid zone where to move the atoms.\n        atoms (list[Atom] | ilist.IList[Atom, NumQubits]): The atoms to be moved.\n\n    Returns:\n        ilist.IList[Atom, NumQubits | Any]: A list of newly created atoms.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/atom/_interface/#bloqade.shuttle.dialects.atom._interface.move_next_to","title":"move_next_to","text":"<pre><code>move_next_to(\n    zone: Grid[Any, Any],\n    ctrls: list[Atom],\n    qargs: list[Atom],\n) -&gt; tuple[\n    ilist.IList[Atom, NumAtoms], ilist.IList[Atom, NumAtoms]\n]\n</code></pre><pre><code>move_next_to(\n    zone: Grid[Any, Any],\n    ctrls: IList[Atom, NumAtoms],\n    qargs: list[Atom],\n) -&gt; tuple[\n    ilist.IList[Atom, NumAtoms], ilist.IList[Atom, NumAtoms]\n]\n</code></pre><pre><code>move_next_to(\n    zone: Grid[Any, Any],\n    ctrls: list[Atom],\n    qargs: IList[Atom, NumAtoms],\n) -&gt; tuple[\n    ilist.IList[Atom, NumAtoms], ilist.IList[Atom, NumAtoms]\n]\n</code></pre><pre><code>move_next_to(\n    zone: Grid[Any, Any],\n    ctrls: IList[Atom, NumAtoms],\n    qargs: IList[Atom, NumAtoms],\n) -&gt; tuple[\n    ilist.IList[Atom, NumAtoms], ilist.IList[Atom, NumAtoms]\n]\n</code></pre> <pre><code>move_next_to(zone, ctrls, qargs)\n</code></pre> <p>Apply an operation to the specified atoms, optionally moving them in the process if the gate operation requires it. After the operation, the atoms potentially change their positions which will be reflected in the returned list.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Grid[Any, Any]</code> <p>The grid zone where the atoms are located.</p> required <code>ctrls</code> <code>list[Atom] | IList[Atom, NumAtoms]</code> <p>The control atoms for the operation.</p> required <code>qargs</code> <code>list[Atom] | IList[Atom, NumAtoms]</code> <p>The target atoms for the operation.</p> required <p>Returns:</p> Type Description <p>tuple[ilist.IList[Atom, NumAtoms], ilist.IList[Atom, NumAtoms]]: A tuple containing two lists of atoms: the control atoms and the target atoms after the operation. the first list contains the updated ctrls, and the second list contains the updated qargs.</p> Source code in <code>src/bloqade/shuttle/dialects/atom/_interface.py</code> <pre><code>@_wraps(MoveNextTo)\ndef move_next_to(zone, ctrls, qargs):\n    \"\"\"\n    Apply an operation to the specified atoms, optionally moving them in the process if the gate operation requires it.\n    After the operation, the atoms potentially change their positions which will be reflected in the returned list.\n\n    Args:\n        zone (grid.Grid[Any, Any]): The grid zone where the atoms are located.\n        ctrls (list[Atom] | ilist.IList[Atom, NumAtoms]): The control atoms for the operation.\n        qargs (list[Atom] | ilist.IList[Atom, NumAtoms]): The target atoms for the operation.\n\n    Returns:\n        tuple[ilist.IList[Atom, NumAtoms], ilist.IList[Atom, NumAtoms]]:\n            A tuple containing two lists of atoms: the control atoms and the target atoms after the operation.\n            the first list contains the updated ctrls, and the second list contains the updated qargs.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/atom/_interface/#bloqade.shuttle.dialects.atom._interface.new","title":"new","text":"<pre><code>new(\n    zone: Grid, qubits: list[Qubit]\n) -&gt; ilist.IList[Atom, Any]\n</code></pre><pre><code>new(\n    zone: Grid, qubits: IList[Qubit, NumQubits]\n) -&gt; ilist.IList[Atom, NumQubits]\n</code></pre> <pre><code>new(zone, qubits)\n</code></pre> <p>Create new atoms in the specified zone with the given qubits.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Grid</code> <p>The grid zone where atoms will be created.</p> required <code>qubits</code> <code>list[Qubit] | IList[Qubit, NumQubits]</code> <p>The qubits associated with the new atoms.</p> required <p>Returns:</p> Type Description <p>ilist.IList[Atom, NumQubits | Any]: A list of newly created atoms.</p> Source code in <code>src/bloqade/shuttle/dialects/atom/_interface.py</code> <pre><code>@_wraps(New)\ndef new(zone, qubits):\n    \"\"\"\n    Create new atoms in the specified zone with the given qubits.\n\n    Args:\n        zone (grid.Grid): The grid zone where atoms will be created.\n        qubits (list[Qubit] | ilist.IList[Qubit, NumQubits]): The qubits associated with the new atoms.\n\n    Returns:\n        ilist.IList[Atom, NumQubits | Any]: A list of newly created atoms.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/atom/_interface/#bloqade.shuttle.dialects.atom._interface.reset_position","title":"reset_position","text":"<pre><code>reset_position(\n    atoms: list[Atom], qubits: list[Qubit]\n) -&gt; None\n</code></pre><pre><code>reset_position(\n    atoms: list[Atom], qubits: IList[Qubit, NumAtoms]\n) -&gt; None\n</code></pre><pre><code>reset_position(\n    atoms: IList[Atom, NumAtoms], qubits: list[Qubit]\n) -&gt; None\n</code></pre><pre><code>reset_position(\n    atoms: IList[Atom, NumAtoms],\n    qubits: IList[Qubit, NumAtoms],\n) -&gt; None\n</code></pre> <pre><code>reset_position(atoms, qubits) -&gt; None\n</code></pre> <p>Reset the position of atoms to their initial state, terminating the moves.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>list[Atom] | IList[Atom, NumAtoms]</code> <p>The atoms whose positions will be reset.</p> required <code>qubits</code> <code>list[Qubit] | IList[Qubit, NumAtoms]</code> <p>The qubits associated with the atoms being reset.</p> required Source code in <code>src/bloqade/shuttle/dialects/atom/_interface.py</code> <pre><code>@_wraps(ResetPosition)\ndef reset_position(atoms, qubits) -&gt; None:\n    \"\"\"\n    Reset the position of atoms to their initial state, terminating the moves.\n\n    Args:\n        atoms (list[Atom] | ilist.IList[Atom, NumAtoms]): The atoms whose positions will be reset.\n        qubits (list[Qubit] | ilist.IList[Qubit, NumAtoms]): The qubits associated with the atoms being reset.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/atom/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/atom/types/","title":"Types","text":""},{"location":"reference/bloqade/shuttle/dialects/filled/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/filled/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/filled/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/filled/concrete/","title":"Concrete","text":""},{"location":"reference/bloqade/shuttle/dialects/filled/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/filled/types/","title":"Types","text":""},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid","title":"FilledGrid  <code>dataclass</code>","text":"<pre><code>FilledGrid(\n    x_spacing: tuple[float, ...],\n    y_spacing: tuple[float, ...],\n    x_init: float | None,\n    y_init: float | None,\n    parent: Grid[NumX, NumY],\n    vacancies: frozenset[tuple[int, int]],\n)\n</code></pre> <p>               Bases: <code>Grid[NumX, NumY]</code></p>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.positions","title":"positions  <code>cached</code> <code>property</code>","text":"<pre><code>positions: IList[tuple[float, float], Any]\n</code></pre> <p>All positions in the grid as a list of tuples (x, y) in lexicographic order.</p>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.x_init","title":"x_init  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x_init: float | None = field(init=False)\n</code></pre> <p>The initial x position of the grid, or None if not set.</p>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.x_spacing","title":"x_spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x_spacing: tuple[float, ...] = field(init=False)\n</code></pre> <p>A tuple of x spacings between grid points.</p>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.y_init","title":"y_init  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_init: float | None = field(init=False)\n</code></pre> <p>The initial y position of the grid, or None if not set.</p>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.y_spacing","title":"y_spacing  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_spacing: tuple[float, ...] = field(init=False)\n</code></pre> <p>A tuple of y spacings between grid points.</p>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.get_view","title":"get_view","text":"<pre><code>get_view(\n    x_indices: IList[int, Any], y_indices: IList[int, Any]\n)\n</code></pre> <p>Get a sub-grid view based on the specified x and y indices.</p> <p>Parameters:</p> Name Type Description Default <code>x_indices</code> <code>Sequence[int]</code> <p>The x indices to include in the sub-grid.</p> required <code>y_indices</code> <code>Sequence[int]</code> <p>The y indices to include in the sub-grid.</p> required <p>Returns:</p> Name Type Description <code>Grid</code> <code>Grid</code> <p>The sub-grid view.</p> Source code in <code>src/bloqade/shuttle/dialects/filled/types.py</code> <pre><code>def get_view(  # type: ignore\n    self, x_indices: ilist.IList[int, Any], y_indices: ilist.IList[int, Any]\n):\n    remapping_x = {ix: i for i, ix in enumerate(x_indices)}\n    remapping_y = {iy: i for i, iy in enumerate(y_indices)}\n    return FilledGrid(\n        parent=self.parent.get_view(x_indices, y_indices),\n        vacancies=frozenset(\n            (remapping_x[x], remapping_y[y])\n            for x, y in self.vacancies\n            if x in remapping_x and y in remapping_y\n        ),\n    )\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: Any) -&gt; bool\n</code></pre> <p>Check if two grid geometry are equal.</p> Source code in <code>src/bloqade/shuttle/dialects/filled/types.py</code> <pre><code>def is_equal(self, other: Any) -&gt; bool:\n    return self == other\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.repeat","title":"repeat","text":"<pre><code>repeat(\n    x_times: int, y_times: int, x_gap: float, y_gap: float\n)\n</code></pre> <p>Repeat the grid in both x and y directions with specified gaps.</p> <p>Parameters:</p> Name Type Description Default <code>x_times</code> <code>int</code> <p>The number of times to repeat the grid in the x direction.</p> required <code>y_times</code> <code>int</code> <p>The number of times to repeat the grid in the y direction.</p> required <code>x_gap</code> <code>float</code> <p>The gap between repeated grids in the x direction.</p> required <code>y_gap</code> <code>float</code> <p>The gap between repeated grids in the y direction.</p> required <p>Returns:</p> Type Description <code>Grid[NumX, NumY]</code> <p>Grid[NumX, NumY]: A new grid with the specified repetitions and gaps.</p> Source code in <code>src/bloqade/shuttle/dialects/filled/types.py</code> <pre><code>def repeat(self, x_times: int, y_times: int, x_gap: float, y_gap: float):\n    new_parent = self.parent.repeat(x_times, y_times, x_gap, y_gap)\n    x_dim, y_dim = self.shape\n    vacancies = frozenset(\n        (x + x_dim * i, y + y_dim * j)\n        for i, j, (x, y) in product(range(x_times), range(y_times), self.vacancies)\n    )\n    return FilledGrid.vacate(new_parent, vacancies)\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.scale","title":"scale","text":"<pre><code>scale(x_scale: float, y_scale: float)\n</code></pre> <p>Scale the grid spacings by the specified x and y factors with fixed x and y initial positions.</p> <p>Parameters:</p> Name Type Description Default <code>x_scale</code> <code>float</code> <p>The scaling factor for the x spacings.</p> required <code>y_scale</code> <code>float</code> <p>The scaling factor for the y spacings.</p> required <p>Returns:</p> Type Description <code>Grid[NumX, NumY]</code> <p>Grid[NumX, NumY]: A new grid with scaled x and y spacings</p> Source code in <code>src/bloqade/shuttle/dialects/filled/types.py</code> <pre><code>def scale(self, x_scale: float, y_scale: float):\n    return FilledGrid(\n        parent=self.parent.scale(x_scale, y_scale),\n        vacancies=self.vacancies,\n    )\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/filled/types/#bloqade.shuttle.dialects.filled.types.FilledGrid.shift","title":"shift","text":"<pre><code>shift(x_shift: float, y_shift: float)\n</code></pre> <p>Shift the grid by the specified x and y amounts.</p> <p>Parameters:</p> Name Type Description Default <code>x_shift</code> <code>float</code> <p>The amount to shift the grid in the x direction.</p> required <code>y_shift</code> <code>float</code> <p>The amount to shift the grid in the y direction.</p> required <p>Returns:</p> Type Description <code>Grid[NumX, NumY]</code> <p>Grid[NumX, NumY]: A new grid with the specified shifts applied to the initial positions.</p> Source code in <code>src/bloqade/shuttle/dialects/filled/types.py</code> <pre><code>def shift(self, x_shift: float, y_shift: float):\n    return FilledGrid(\n        parent=self.parent.shift(x_shift, y_shift),\n        vacancies=self.vacancies,\n    )\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/gate/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/gate/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/gate/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/gate/_interface/#bloqade.shuttle.dialects.gate._interface.global_r","title":"global_r","text":"<pre><code>global_r(axis_angle: float, rotation_angle: float)\n</code></pre> <p>Apply a global R gate over all zones.</p> <p>Parameters:</p> Name Type Description Default <code>axis_angle</code> <code>float</code> <p>The angle of the axis for the R gate.</p> required <code>rotation_angle</code> <code>float</code> <p>The angle of rotation for the R gate.</p> required Source code in <code>src/bloqade/shuttle/dialects/gate/_interface.py</code> <pre><code>@_wraps(GlobalR)\ndef global_r(axis_angle: float, rotation_angle: float):\n    \"\"\"Apply a global R gate over all zones.\n\n    Args:\n        axis_angle (float): The angle of the axis for the R gate.\n        rotation_angle (float): The angle of rotation for the R gate.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/gate/_interface/#bloqade.shuttle.dialects.gate._interface.global_rz","title":"global_rz","text":"<pre><code>global_rz(rotation_angle: float)\n</code></pre> <p>Apply a global Rz gate over all zones.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_angle</code> <code>float</code> <p>The angle of rotation for the Rz gate.</p> required Source code in <code>src/bloqade/shuttle/dialects/gate/_interface.py</code> <pre><code>@_wraps(GlobalRz)\ndef global_rz(rotation_angle: float):\n    \"\"\"Apply a global Rz gate over all zones.\n\n    Args:\n        rotation_angle (float): The angle of rotation for the Rz gate.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/gate/_interface/#bloqade.shuttle.dialects.gate._interface.local_r","title":"local_r","text":"<pre><code>local_r(\n    axis_angle: float,\n    rotation_angle: float,\n    zone: Grid[Any, Any],\n) -&gt; None\n</code></pre> <p>Apply a local Rz gate to a zone.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_angle</code> <code>float</code> <p>The angle of rotation for the Rz gate.</p> required <code>zone</code> <code>GridType[Any, Any]</code> <p>The grid zone where the gate is applied.</p> required Source code in <code>src/bloqade/shuttle/dialects/gate/_interface.py</code> <pre><code>@_wraps(LocalR)\ndef local_r(\n    axis_angle: float, rotation_angle: float, zone: grid.Grid[Any, Any]\n) -&gt; None:\n    \"\"\"Apply a local Rz gate to a zone.\n\n    Args:\n        rotation_angle (float): The angle of rotation for the Rz gate.\n        zone (grid.GridType[Any, Any]): The grid zone where the gate is applied.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/gate/_interface/#bloqade.shuttle.dialects.gate._interface.local_rz","title":"local_rz","text":"<pre><code>local_rz(\n    rotation_angle: float, zone: Grid[Any, Any]\n) -&gt; None\n</code></pre> <p>Apply a local Rz gate to a zone.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_angle</code> <code>float</code> <p>The angle of rotation for the Rz gate.</p> required <code>zone</code> <code>GridType[Any, Any]</code> <p>The grid zone where the gate is applied.</p> required Source code in <code>src/bloqade/shuttle/dialects/gate/_interface.py</code> <pre><code>@_wraps(LocalRz)\ndef local_rz(rotation_angle: float, zone: grid.Grid[Any, Any]) -&gt; None:\n    \"\"\"Apply a local Rz gate to a zone.\n\n    Args:\n        rotation_angle (float): The angle of rotation for the Rz gate.\n        zone (grid.GridType[Any, Any]): The grid zone where the gate is applied.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/gate/_interface/#bloqade.shuttle.dialects.gate._interface.top_hat_cz","title":"top_hat_cz","text":"<pre><code>top_hat_cz(\n    zone: Grid[Any, Any],\n    upper_buffer: float = 3.0,\n    lower_buffer: float = 3.0,\n) -&gt; None\n</code></pre> <p>Apply a top hat CZ gate.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>GridType[Any, Any]</code> <p>The grid zone where the gate is applied.</p> required <code>upper_buffer</code> <code>float</code> <p>The upper buffer distance for the top hat above the zone.</p> <code>3.0</code> <code>lower_buffer</code> <code>float</code> <p>The lower buffer distance for the top hat below the zone.</p> <code>3.0</code> Source code in <code>src/bloqade/shuttle/dialects/gate/_interface.py</code> <pre><code>@_wraps(TopHatCZ)\ndef top_hat_cz(\n    zone: grid.Grid[Any, Any],\n    upper_buffer: float = 3.0,\n    lower_buffer: float = 3.0,\n) -&gt; None:\n    \"\"\"Apply a top hat CZ gate.\n\n    Args:\n        zone (grid.GridType[Any, Any]): The grid zone where the gate is applied.\n        upper_buffer (float): The upper buffer distance for the top hat above the zone.\n        lower_buffer (float): The lower buffer distance for the top hat below the zone.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/gate/runtime/","title":"Runtime","text":""},{"location":"reference/bloqade/shuttle/dialects/gate/runtime/#bloqade.shuttle.dialects.gate.runtime.HasQuantumRuntimeMethodTable","title":"HasQuantumRuntimeMethodTable","text":"<p>               Bases: <code>MethodTable</code></p>"},{"location":"reference/bloqade/shuttle/dialects/gate/runtime/#bloqade.shuttle.dialects.gate.runtime.HasQuantumRuntimeMethodTable.gate","title":"gate","text":"<pre><code>gate(\n    interp: RuntimeAnalysis,\n    frame: RuntimeFrame,\n    stmt: TopHatCZ | LocalRz | LocalR | GlobalR | GlobalRz,\n) -&gt; interp.StatementResult[RuntimeFrame]\n</code></pre> <p>Handle gate statements and mark the frame as quantum.</p> Source code in <code>src/bloqade/shuttle/dialects/gate/runtime.py</code> <pre><code>@interp.impl(TopHatCZ)\n@interp.impl(LocalRz)\n@interp.impl(LocalR)\n@interp.impl(GlobalR)\n@interp.impl(GlobalRz)\ndef gate(\n    self,\n    interp: RuntimeAnalysis,\n    frame: RuntimeFrame,\n    stmt: TopHatCZ | LocalRz | LocalR | GlobalR | GlobalRz,\n) -&gt; interp.StatementResult[RuntimeFrame]:\n    \"\"\"Handle gate statements and mark the frame as quantum.\"\"\"\n    frame.is_quantum = True\n    frame.quantum_stmts.add(stmt)\n    return ()\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/gate/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/gate/stmts/#bloqade.shuttle.dialects.gate.stmts.GlobalR","title":"GlobalR  <code>kirin-statement</code>","text":"<pre><code>GlobalR(axis_angle: SSAValue, rotation_angle: SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Apply gate op globally</p>"},{"location":"reference/bloqade/shuttle/dialects/gate/stmts/#bloqade.shuttle.dialects.gate.stmts.GlobalRz","title":"GlobalRz  <code>kirin-statement</code>","text":"<pre><code>GlobalRz(rotation_angle: SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Apply gate op globally</p>"},{"location":"reference/bloqade/shuttle/dialects/gate/stmts/#bloqade.shuttle.dialects.gate.stmts.LocalR","title":"LocalR  <code>kirin-statement</code>","text":"<pre><code>LocalR(\n    axis_angle: SSAValue,\n    rotation_angle: SSAValue,\n    zone: SSAValue,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Apply gate op locally</p>"},{"location":"reference/bloqade/shuttle/dialects/gate/stmts/#bloqade.shuttle.dialects.gate.stmts.LocalRz","title":"LocalRz  <code>kirin-statement</code>","text":"<pre><code>LocalRz(rotation_angle: SSAValue, zone: SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Apply gate op locally</p>"},{"location":"reference/bloqade/shuttle/dialects/init/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/init/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/init/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/init/_interface/#bloqade.shuttle.dialects.init._interface.fill","title":"fill","text":"<pre><code>fill(\n    locations: (\n        IList[Grid[Any, Any], Any] | list[Grid[Any, Any]]\n    ),\n)\n</code></pre> <p>Fill the given locations with the given value.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>IList[Grid[Any, Any], Any]</code> <p>The locations to fill. Note that these locations must be valid static trap locations.</p> required Source code in <code>src/bloqade/shuttle/dialects/init/_interface.py</code> <pre><code>@_wraps(Fill)\ndef fill(\n    locations: ilist.IList[grid.Grid[Any, Any], Any] | list[grid.Grid[Any, Any]],\n):\n    \"\"\"Fill the given locations with the given value.\n\n    Args:\n        locations (ilist.IList[grid.Grid[Any,Any], Any]): The locations to fill.\n            Note that these locations must be valid static trap locations.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/init/runtime/","title":"Runtime","text":""},{"location":"reference/bloqade/shuttle/dialects/init/runtime/#bloqade.shuttle.dialects.init.runtime.HasQuantumRuntimeMethodTable","title":"HasQuantumRuntimeMethodTable","text":"<p>               Bases: <code>MethodTable</code></p>"},{"location":"reference/bloqade/shuttle/dialects/init/runtime/#bloqade.shuttle.dialects.init.runtime.HasQuantumRuntimeMethodTable.gate","title":"gate","text":"<pre><code>gate(\n    interp: RuntimeAnalysis, frame: RuntimeFrame, stmt: Fill\n)\n</code></pre> <p>Handle gate statements and mark the frame as quantum.</p> Source code in <code>src/bloqade/shuttle/dialects/init/runtime.py</code> <pre><code>@interp.impl(Fill)\ndef gate(self, interp: RuntimeAnalysis, frame: RuntimeFrame, stmt: Fill):\n    \"\"\"Handle gate statements and mark the frame as quantum.\"\"\"\n    frame.is_quantum = True\n    frame.quantum_stmts.add(stmt)\n    return ()\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/init/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/measure/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/measure/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/measure/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/measure/_interface/#bloqade.shuttle.dialects.measure._interface.measure","title":"measure","text":"<pre><code>measure(\n    regions: tuple[Grid[NumX, NumY], ...],\n) -&gt; tuple[MeasurementArray[NumX, NumY], ...]\n</code></pre> <p>Measure the given regions and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>regions</code> <code>tuple[Grid[NumX, NumY], ...]</code> <p>A tuple of regions to measure.</p> required <p>Returns:</p> Type Description <code>tuple[MeasurementArray[NumX, NumY], ...]</code> <p>A tuple of measurement results.</p> Source code in <code>src/bloqade/shuttle/dialects/measure/_interface.py</code> <pre><code>@wraps(Measure)\ndef measure(\n    regions: tuple[grid.Grid[NumX, NumY], ...],\n) -&gt; tuple[MeasurementArray[NumX, NumY], ...]:\n    \"\"\"\n    Measure the given regions and return the results.\n\n    Args:\n        regions: A tuple of regions to measure.\n\n    Returns:\n        A tuple of measurement results.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/measure/runtime/","title":"Runtime","text":""},{"location":"reference/bloqade/shuttle/dialects/measure/runtime/#bloqade.shuttle.dialects.measure.runtime.HasQuantumRuntimeMethodTable","title":"HasQuantumRuntimeMethodTable","text":"<p>               Bases: <code>MethodTable</code></p>"},{"location":"reference/bloqade/shuttle/dialects/measure/runtime/#bloqade.shuttle.dialects.measure.runtime.HasQuantumRuntimeMethodTable.gate","title":"gate","text":"<pre><code>gate(\n    _interp: RuntimeAnalysis,\n    frame: RuntimeFrame,\n    stmt: Measure,\n)\n</code></pre> <p>Handle gate statements and mark the frame as quantum.</p> Source code in <code>src/bloqade/shuttle/dialects/measure/runtime.py</code> <pre><code>@interp.impl(Measure)\ndef gate(self, _interp: RuntimeAnalysis, frame: RuntimeFrame, stmt: Measure):\n    \"\"\"Handle gate statements and mark the frame as quantum.\"\"\"\n    frame.is_quantum = True\n    frame.quantum_stmts.add(stmt)\n    return (_interp.lattice.top(),)\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/measure/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/measure/types/","title":"Types","text":""},{"location":"reference/bloqade/shuttle/dialects/measure/types/#bloqade.shuttle.dialects.measure.types.MeasurementArray","title":"MeasurementArray","text":"<p>               Bases: <code>Generic[NumRows, NumCols]</code></p>"},{"location":"reference/bloqade/shuttle/dialects/measure/types/#bloqade.shuttle.dialects.measure.types.MeasurementArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(indices: tuple[int, int]) -&gt; MeasurementResult\n</code></pre> <p>Get a measurement result from the array using the given indices.</p> Source code in <code>src/bloqade/shuttle/dialects/measure/types.py</code> <pre><code>def __getitem__(self, indices: tuple[int, int]) -&gt; MeasurementResult:\n    \"\"\"\n    Get a measurement result from the array using the given indices.\n    \"\"\"\n    raise NotImplementedError(\n        \"This Class is a placeholder and should be replaced with the actual implementation.\"\n    )\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/path/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/path/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/path/concrete/","title":"Concrete","text":""},{"location":"reference/bloqade/shuttle/dialects/path/constprop/","title":"Constprop","text":""},{"location":"reference/bloqade/shuttle/dialects/path/runtime/","title":"Runtime","text":""},{"location":"reference/bloqade/shuttle/dialects/path/runtime/#bloqade.shuttle.dialects.path.runtime.HasQuantumRuntimeMethodTable","title":"HasQuantumRuntimeMethodTable","text":"<p>               Bases: <code>MethodTable</code></p>"},{"location":"reference/bloqade/shuttle/dialects/path/runtime/#bloqade.shuttle.dialects.path.runtime.HasQuantumRuntimeMethodTable.gate","title":"gate","text":"<pre><code>gate(\n    interp: RuntimeAnalysis, frame: RuntimeFrame, stmt: Play\n) -&gt; interp.StatementResult[RuntimeFrame]\n</code></pre> <p>Handle gate statements and mark the frame as quantum.</p> Source code in <code>src/bloqade/shuttle/dialects/path/runtime.py</code> <pre><code>@interp.impl(Play)\ndef gate(\n    self, interp: RuntimeAnalysis, frame: RuntimeFrame, stmt: Play\n) -&gt; interp.StatementResult[RuntimeFrame]:\n    \"\"\"Handle gate statements and mark the frame as quantum.\"\"\"\n    frame.is_quantum = True\n    frame.quantum_stmts.add(stmt)\n    return ()\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/path/spec_interp/","title":"Spec interp","text":""},{"location":"reference/bloqade/shuttle/dialects/path/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/path/types/","title":"Types","text":""},{"location":"reference/bloqade/shuttle/dialects/schedule/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/schedule/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/schedule/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/schedule/_interface/#bloqade.shuttle.dialects.schedule._interface.device_fn","title":"device_fn","text":"<pre><code>device_fn(\n    move_fn: Method[Param, None],\n    x_tones: list[int] | IList[int, Any],\n    y_tones: list[int] | IList[int, Any],\n) -&gt; DeviceFunction[Param]\n</code></pre> <p>Create a device function from a move function.</p> <p>Parameters:</p> Name Type Description Default <code>move_fn</code> <code>Callable</code> <p>The move function to be wrapped.</p> required <code>x_tones</code> <code>list[int]|</code> <p>The x tones to be used in the device function.</p> required <code>y_tones</code> <code>list[int] | IList[int, Any]</code> <p>The y tones to be used in the device function.</p> required Source code in <code>src/bloqade/shuttle/dialects/schedule/_interface.py</code> <pre><code>@_wraps(NewDeviceFunction)\ndef device_fn(\n    move_fn: ir.Method[Param, None],\n    x_tones: list[int] | ilist.IList[int, Any],\n    y_tones: list[int] | ilist.IList[int, Any],\n) -&gt; DeviceFunction[Param]:\n    \"\"\"Create a device function from a move function.\n\n    Args:\n        move_fn (Callable): The move function to be wrapped.\n        x_tones (list[int]|): The x tones to be used in the device function.\n        y_tones: The y tones to be used in the device function.\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/schedule/_interface/#bloqade.shuttle.dialects.schedule._interface.reverse","title":"reverse","text":"<pre><code>reverse(\n    device_fn: DeviceFunction[Param],\n) -&gt; ReverseDeviceFunction[Param]\n</code></pre> <p>Create a reverse device function from a device function.</p> <p>Parameters:</p> Name Type Description Default <code>device_fn</code> <code>DeviceFunction</code> <p>The device function to be reversed.</p> required Source code in <code>src/bloqade/shuttle/dialects/schedule/_interface.py</code> <pre><code>@_wraps(Reverse)\ndef reverse(\n    device_fn: DeviceFunction[Param],\n) -&gt; ReverseDeviceFunction[Param]:\n    \"\"\"Create a reverse device function from a device function.\n\n    Args:\n        device_fn (DeviceFunction): The device function to be reversed.\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/schedule/concrete/","title":"Concrete","text":""},{"location":"reference/bloqade/shuttle/dialects/schedule/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/dialects/schedule/types/","title":"Types","text":""},{"location":"reference/bloqade/shuttle/dialects/spec/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/dialects/spec/_dialect/","title":"dialect","text":""},{"location":"reference/bloqade/shuttle/dialects/spec/_interface/","title":"statements","text":""},{"location":"reference/bloqade/shuttle/dialects/spec/_interface/#bloqade.shuttle.dialects.spec._interface.get_special_grid","title":"get_special_grid","text":"<pre><code>get_special_grid(*, grid_id: str) -&gt; grid.Grid[Any, Any]\n</code></pre> <p>Get a special grid by its ID.</p> Source code in <code>src/bloqade/shuttle/dialects/spec/_interface.py</code> <pre><code>@_wraps(GetSpecialGrid)\ndef get_special_grid(*, grid_id: str) -&gt; grid.Grid[Any, Any]:\n    \"\"\"Get a special grid by its ID.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/spec/_interface/#bloqade.shuttle.dialects.spec._interface.get_static_trap","title":"get_static_trap","text":"<pre><code>get_static_trap(*, zone_id: str) -&gt; grid.Grid[Any, Any]\n</code></pre> <p>Get a static trap by its zone ID.</p> Source code in <code>src/bloqade/shuttle/dialects/spec/_interface.py</code> <pre><code>@_wraps(GetStaticTrap)\ndef get_static_trap(*, zone_id: str) -&gt; grid.Grid[Any, Any]:\n    \"\"\"Get a static trap by its zone ID.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/dialects/spec/concrete/","title":"Concrete","text":""},{"location":"reference/bloqade/shuttle/dialects/spec/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/shuttle/passes/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/passes/fold/","title":"Fold","text":""},{"location":"reference/bloqade/shuttle/passes/fold/#bloqade.shuttle.passes.fold.AggressiveUnroll","title":"AggressiveUnroll  <code>dataclass</code>","text":"<pre><code>AggressiveUnroll()\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>Fold pass to fold control flow</p>"},{"location":"reference/bloqade/shuttle/passes/fold/#bloqade.shuttle.passes.fold.AggressiveUnroll.inline_heuristic","title":"inline_heuristic  <code>classmethod</code>","text":"<pre><code>inline_heuristic(node: Statement) -&gt; bool\n</code></pre> <p>The heuristic to decide whether to inline a function call or not. inside loops and if-else, only inline simple functions, i.e. functions with a single block</p> Source code in <code>src/bloqade/shuttle/passes/fold.py</code> <pre><code>@classmethod\ndef inline_heuristic(cls, node: ir.Statement) -&gt; bool:\n    \"\"\"The heuristic to decide whether to inline a function call or not.\n    inside loops and if-else, only inline simple functions, i.e.\n    functions with a single block\n    \"\"\"\n    return not isinstance(\n        node.parent_stmt, (scf.For, scf.IfElse)\n    )  # always inline calls outside of loops and if-else\n</code></pre>"},{"location":"reference/bloqade/shuttle/passes/hint_zone/","title":"Hint zone","text":""},{"location":"reference/bloqade/shuttle/passes/hint_zone/#bloqade.shuttle.passes.hint_zone.HintZone","title":"HintZone  <code>dataclass</code>","text":"<pre><code>HintZone(arch_spec: ArchSpec)\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>This pass adds zone hints to SSA values based on the analysis results.</p>"},{"location":"reference/bloqade/shuttle/passes/inject_spec/","title":"Inject spec","text":""},{"location":"reference/bloqade/shuttle/passes/schedule2path/","title":"Schedule2path","text":""},{"location":"reference/bloqade/shuttle/passes/schedule2path/#bloqade.shuttle.passes.schedule2path.ScheduleToPath","title":"ScheduleToPath","text":"<p>               Bases: <code>Pass</code></p> <p>Pass to convert schedule dialect to path dialect.</p>"},{"location":"reference/bloqade/shuttle/rewrite/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/rewrite/auto_scheduler/","title":"Auto scheduler","text":""},{"location":"reference/bloqade/shuttle/rewrite/desugar/","title":"Desugar","text":""},{"location":"reference/bloqade/shuttle/rewrite/schedule2path/","title":"Schedule2path","text":""},{"location":"reference/bloqade/shuttle/rewrite/schedule2path/#bloqade.shuttle.rewrite.schedule2path.Canonicalize","title":"Canonicalize","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Flatten nested parallel regions into a single parallel region.</p>"},{"location":"reference/bloqade/shuttle/stdlib/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/stdlib/moves/","title":"Moves","text":""},{"location":"reference/bloqade/shuttle/stdlib/moves/#bloqade.shuttle.stdlib.moves.default_move_cz_impl","title":"default_move_cz_impl","text":"<pre><code>default_move_cz_impl(\n    zone: Grid[Any, Any],\n    x_shift: float,\n    y_shift: float,\n    ctrl_x_ids: IList[int, NumX],\n    ctrl_y_ids: IList[int, NumY],\n    qarg_x_ids: IList[int, NumX],\n    qarg_y_ids: IList[int, NumY],\n)\n</code></pre> <p>Move atoms from the start ids and run cz gate with the atoms at the end ids.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl_x_ids</code> <code>IList[int, NumX]</code> <p>The x-indices of the starting positions.</p> required <code>ctrl_y_ids</code> <code>IList[int, NumY]</code> <p>The y-indices of the starting positions.</p> required <code>qarg_x_ids</code> <code>IList[int, NumX]</code> <p>The x-indices of the ending positions.</p> required <code>qarg_y_ids</code> <code>IList[int, NumY]</code> <p>The y-indices of the ending positions.</p> required Source code in <code>src/bloqade/shuttle/stdlib/moves.py</code> <pre><code>@move\ndef default_move_cz_impl(\n    zone: grid.Grid[Any, Any],\n    x_shift: float,\n    y_shift: float,\n    ctrl_x_ids: ilist.IList[int, NumX],\n    ctrl_y_ids: ilist.IList[int, NumY],\n    qarg_x_ids: ilist.IList[int, NumX],\n    qarg_y_ids: ilist.IList[int, NumY],\n):\n    \"\"\"Move atoms from the start ids and run cz gate with the atoms at the end ids.\n\n    Args:\n        ctrl_x_ids (ilist.IList[int, NumX]): The x-indices of the starting positions.\n        ctrl_y_ids (ilist.IList[int, NumY]): The y-indices of the starting positions.\n        qarg_x_ids (ilist.IList[int, NumX]): The x-indices of the ending positions.\n        qarg_y_ids (ilist.IList[int, NumY]): The y-indices of the ending positions.\n    \"\"\"\n    if len(ctrl_x_ids) &lt; 1 or len(qarg_x_ids) &lt; 1:\n        return\n\n    fwd_kernel = schedule.device_fn(\n        single_zone_move_cz,\n        ilist.range(len(ctrl_x_ids)),\n        ilist.range(len(ctrl_y_ids)),\n    )\n    bwd_kernel = schedule.reverse(fwd_kernel)\n\n    fwd_kernel(zone, ctrl_x_ids, ctrl_y_ids, qarg_x_ids, qarg_y_ids, x_shift, y_shift)\n    gate.top_hat_cz(zone)\n    bwd_kernel(zone, qarg_x_ids, qarg_y_ids, ctrl_x_ids, ctrl_y_ids, x_shift, y_shift)\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/spec/","title":"Spec","text":""},{"location":"reference/bloqade/shuttle/stdlib/spec/#bloqade.shuttle.stdlib.spec.single_zone_spec","title":"single_zone_spec","text":"<pre><code>single_zone_spec(\n    num_x: int, num_y: int, spacing: float = 10.0\n) -&gt; spec.ArchSpec\n</code></pre> <p>Create a static trap spec with a single zone. compatible with the stdlib</p> <p>Parameters:</p> Name Type Description Default <code>num_x</code> <code>int</code> <p>Number of traps in the x direction.</p> required <code>num_y</code> <code>int</code> <p>Number of traps in the y direction.</p> required <code>spacing</code> <code>float</code> <p>Spacing between traps in both directions. Default is 10.0.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>ArchSpec</code> <p>spec.Spec: A specification object containing the layout with a single zone.</p> Source code in <code>src/bloqade/shuttle/stdlib/spec.py</code> <pre><code>def single_zone_spec(num_x: int, num_y: int, spacing: float = 10.0) -&gt; spec.ArchSpec:\n    \"\"\"Create a static trap spec with a single zone. compatible with the stdlib\n\n    Args:\n        num_x (int): Number of traps in the x direction.\n        num_y (int): Number of traps in the y direction.\n        spacing (float): Spacing between traps in both directions. Default is 10.0.\n\n    Returns:\n        spec.Spec: A specification object containing the layout with a single zone.\n\n    \"\"\"\n    x_spacing = tuple(repeat(spacing, num_x - 1))\n    y_spacing = tuple(repeat(spacing, num_y - 1))\n\n    return spec.ArchSpec(\n        layout=spec.Layout(\n            static_traps={\"traps\": grid.Grid(x_spacing, y_spacing, 0.0, 0.0)},\n            fillable=set([\"traps\"]),\n            has_cz=set([\"traps\"]),\n            has_local=set([\"traps\"]),\n        )\n    )\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/waypoints/","title":"Waypoints","text":""},{"location":"reference/bloqade/shuttle/stdlib/waypoints/#bloqade.shuttle.stdlib.waypoints.move_by_waypoints","title":"move_by_waypoints","text":"<pre><code>move_by_waypoints(\n    waypoints: IList[Grid[NumX, NumY], NumWaypoints],\n    pick: bool = True,\n    drop: bool = True,\n)\n</code></pre> <p>Move the tweezer by a list of waypoints.</p> <p>Parameters:</p> Name Type Description Default <code>waypoints</code> <code>IList[Grid[NumX, NumY], NumWaypoints]</code> <p>The waypoints to move to.</p> required <code>pick</code> <code>bool</code> <p>Whether to pick up the tweezer at the first waypoint. Defaults to True.</p> <code>True</code> <code>drop</code> <code>bool</code> <p>Whether to drop the tweezer at the last waypoint. Defaults to True.</p> <code>True</code> Source code in <code>src/bloqade/shuttle/stdlib/waypoints.py</code> <pre><code>@move\ndef move_by_waypoints(\n    waypoints: ilist.IList[grid.Grid[NumX, NumY], NumWaypoints],\n    pick: bool = True,\n    drop: bool = True,\n):\n    \"\"\"Move the tweezer by a list of waypoints.\n\n    Args:\n        waypoints (ilist.IList[grid.Grid[NumX, NumY], NumWaypoints]): The waypoints to move to.\n        pick (bool): Whether to pick up the tweezer at the first waypoint. Defaults to True.\n        drop (bool): Whether to drop the tweezer at the last waypoint. Defaults to True.\n\n    \"\"\"\n    if len(waypoints) &lt; 1:\n        return\n\n    shape = grid.shape(waypoints[0])\n    device_kernel = schedule.device_fn(\n        move_by_waypoints_kernel,\n        ilist.range(shape[0]),\n        ilist.range(shape[1]),\n    )\n    device_kernel(waypoints, pick, drop)\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/waypoints/#bloqade.shuttle.stdlib.waypoints.move_by_waypoints_kernel","title":"move_by_waypoints_kernel","text":"<pre><code>move_by_waypoints_kernel(\n    waypoints: IList[Grid[NumX, NumY], NumWaypoints],\n    pick: bool,\n    drop: bool,\n)\n</code></pre> <p>Pick up the tweezer at the specified location.</p> Source code in <code>src/bloqade/shuttle/stdlib/waypoints.py</code> <pre><code>@tweezer\ndef move_by_waypoints_kernel(\n    waypoints: ilist.IList[grid.Grid[NumX, NumY], NumWaypoints],\n    pick: bool,\n    drop: bool,\n):\n    \"\"\"Pick up the tweezer at the specified location.\"\"\"\n    action.set_loc(waypoints[0])\n    if pick:\n        action.turn_on(action.ALL, action.ALL)\n\n    num_waypoints = len(waypoints)\n    for i in range(1, num_waypoints):\n        action.move(waypoints[i])\n\n    if drop:\n        action.turn_off(action.ALL, action.ALL)\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/stdlib/layouts/asserts/","title":"Asserts","text":""},{"location":"reference/bloqade/shuttle/stdlib/layouts/single_col_zone/","title":"Single col zone","text":""},{"location":"reference/bloqade/shuttle/stdlib/layouts/single_col_zone/#bloqade.shuttle.stdlib.layouts.single_col_zone.default_move_cz_impl","title":"default_move_cz_impl","text":"<pre><code>default_move_cz_impl(\n    zone: Grid[Any, Any],\n    x_shift: float,\n    y_shift: float,\n    ctrl_x_ids: IList[int, NumX],\n    ctrl_y_ids: IList[int, NumY],\n    qarg_x_ids: IList[int, NumX],\n    qarg_y_ids: IList[int, NumY],\n)\n</code></pre> <p>Move atoms from the start ids and run cz gate with the atoms at the end ids.</p> <p>Parameters:</p> Name Type Description Default <code>zone</code> <code>Grid[Any, Any]</code> <p>The grid representing the trap layout (zone) in which atoms are moved.</p> required <code>x_shift</code> <code>float</code> <p>The amount to shift atoms in the x direction during the move.</p> required <code>y_shift</code> <code>float</code> <p>The amount to shift atoms in the y direction during the move.</p> required <code>ctrl_x_ids</code> <code>IList[int, NumX]</code> <p>The x-indices of the starting positions.</p> required <code>ctrl_y_ids</code> <code>IList[int, NumY]</code> <p>The y-indices of the starting positions.</p> required <code>qarg_x_ids</code> <code>IList[int, NumX]</code> <p>The x-indices of the ending positions.</p> required <code>qarg_y_ids</code> <code>IList[int, NumY]</code> <p>The y-indices of the ending positions.</p> required Source code in <code>src/bloqade/shuttle/stdlib/layouts/single_col_zone.py</code> <pre><code>@move\ndef default_move_cz_impl(\n    zone: grid.Grid[Any, Any],\n    x_shift: float,\n    y_shift: float,\n    ctrl_x_ids: ilist.IList[int, NumX],\n    ctrl_y_ids: ilist.IList[int, NumY],\n    qarg_x_ids: ilist.IList[int, NumX],\n    qarg_y_ids: ilist.IList[int, NumY],\n):\n    \"\"\"Move atoms from the start ids and run cz gate with the atoms at the end ids.\n\n    Args:\n        zone (grid.Grid[Any, Any]): The grid representing the trap layout (zone) in which atoms are moved.\n        x_shift (float): The amount to shift atoms in the x direction during the move.\n        y_shift (float): The amount to shift atoms in the y direction during the move.\n        ctrl_x_ids (ilist.IList[int, NumX]): The x-indices of the starting positions.\n        ctrl_y_ids (ilist.IList[int, NumY]): The y-indices of the starting positions.\n        qarg_x_ids (ilist.IList[int, NumX]): The x-indices of the ending positions.\n        qarg_y_ids (ilist.IList[int, NumY]): The y-indices of the ending positions.\n    \"\"\"\n    if len(ctrl_x_ids) &lt; 1 or len(qarg_x_ids) &lt; 1:\n        return\n\n    fwd_kernel = schedule.device_fn(\n        single_zone_move_cz,\n        ilist.range(len(ctrl_x_ids)),\n        ilist.range(len(ctrl_y_ids)),\n    )\n    bwd_kernel = schedule.reverse(fwd_kernel)\n\n    fwd_kernel(zone, ctrl_x_ids, ctrl_y_ids, qarg_x_ids, qarg_y_ids, x_shift, y_shift)\n    gate.top_hat_cz(zone)\n    bwd_kernel(zone, qarg_x_ids, qarg_y_ids, ctrl_x_ids, ctrl_y_ids, x_shift, y_shift)\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/single_col_zone/#bloqade.shuttle.stdlib.layouts.single_col_zone.get_spec","title":"get_spec","text":"<pre><code>get_spec(\n    num_x: int, num_y: int, spacing: float = 10.0\n) -&gt; spec.ArchSpec\n</code></pre> <p>Create a static trap spec with a single zone. compatible with the stdlib</p> <p>Parameters:</p> Name Type Description Default <code>num_x</code> <code>int</code> <p>Number of traps in the x direction.</p> required <code>num_y</code> <code>int</code> <p>Number of traps in the y direction.</p> required <code>spacing</code> <code>float</code> <p>Spacing between traps in both directions. Default is 10.0.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>ArchSpec</code> <p>spec.Spec: A specification object containing the layout with a single zone.</p> Source code in <code>src/bloqade/shuttle/stdlib/layouts/single_col_zone.py</code> <pre><code>def get_spec(num_x: int, num_y: int, spacing: float = 10.0) -&gt; spec.ArchSpec:\n    \"\"\"Create a static trap spec with a single zone. compatible with the stdlib\n\n    Args:\n        num_x (int): Number of traps in the x direction.\n        num_y (int): Number of traps in the y direction.\n        spacing (float): Spacing between traps in both directions. Default is 10.0.\n\n    Returns:\n        spec.Spec: A specification object containing the layout with a single zone.\n\n    \"\"\"\n    x_spacing = tuple(repeat(spacing, num_x - 1))\n    y_spacing = tuple(repeat(spacing, num_y - 1))\n\n    return spec.ArchSpec(\n        layout=spec.Layout(\n            {\"traps\": grid.Grid(x_spacing, y_spacing, 0.0, 0.0)},\n            set([\"traps\"]),\n            set([\"traps\"]),\n            set([\"traps\"]),\n        )\n    )\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/two_col_zone/","title":"Two col zone","text":""},{"location":"reference/bloqade/shuttle/stdlib/layouts/two_col_zone/#bloqade.shuttle.stdlib.layouts.two_col_zone.get_spec","title":"get_spec","text":"<pre><code>get_spec(\n    num_x: int,\n    num_y: int,\n    spacing: float = 10.0,\n    gate_spacing: float = 2.0,\n) -&gt; spec.ArchSpec\n</code></pre> <p>Create a static trap spec with a single zone with pairs of traps oriented horizontally.</p> <p>Parameters:</p> Name Type Description Default <code>num_x</code> <code>int</code> <p>Number of pairs of traps in the x direction.</p> required <code>num_y</code> <code>int</code> <p>Number of pairs of traps in the y direction.</p> required <code>spacing</code> <code>float</code> <p>Spacing between traps in both directions. Default is 10.0.</p> <code>10.0</code> <code>gate_spacing</code> <code>float</code> <p>Spacing between gates. Default is 2.0.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>ArchSpec</code> <p>spec.Spec: A specification object containing the layout with a single zone.</p> Source code in <code>src/bloqade/shuttle/stdlib/layouts/two_col_zone.py</code> <pre><code>def get_spec(\n    num_x: int, num_y: int, spacing: float = 10.0, gate_spacing: float = 2.0\n) -&gt; spec.ArchSpec:\n    \"\"\"Create a static trap spec with a single zone with pairs of traps oriented\n    horizontally.\n\n    Args:\n        num_x (int): Number of pairs of traps in the x direction.\n        num_y (int): Number of pairs of traps in the y direction.\n        spacing (float): Spacing between traps in both directions. Default is 10.0.\n        gate_spacing (float): Spacing between gates. Default is 2.0.\n\n    Returns:\n        spec.Spec: A specification object containing the layout with a single zone.\n\n    \"\"\"\n    x_spacing = sum(repeat((gate_spacing, spacing), num_x - 1), ()) + (gate_spacing,)\n    y_spacing = tuple(repeat(spacing, num_y - 1))\n    all_traps = grid.Grid(x_spacing, y_spacing, 0.0, 0.0)\n    left_trap_x_indices = ilist.IList(range(0, num_x * 2, 2))\n    right_trap_x_indices = ilist.IList(range(1, num_x * 2, 2))\n    all_y_indices = ilist.IList(range(num_y))\n    left_traps = all_traps.get_view(left_trap_x_indices, all_y_indices)\n    right_traps = all_traps.get_view(right_trap_x_indices, all_y_indices)\n\n    return spec.ArchSpec(\n        layout=spec.Layout(\n            {\"traps\": all_traps, \"left_traps\": left_traps, \"right_traps\": right_traps},\n            set([\"left_traps\"]),\n            set([\"traps\"]),\n            set([\"traps\"]),\n        )\n    )\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/base_spec/","title":"Base spec","text":""},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/","title":"Logical","text":""},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/#bloqade.shuttle.stdlib.layouts.gemini.logical.get_block","title":"get_block","text":"<pre><code>get_block(\n    block_id: str,\n    col_indices: IList[int, Any],\n    row_indices: IList[int, Any],\n)\n</code></pre> <p>Returns the zone corresponding to the specified block and column.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>str</code> <p>The block identifier, either \"GL\" or \"GR\".</p> required <code>col_indices</code> <code>IList[int, Any]</code> <p>The list of logical column indices.</p> required <code>row_indices</code> <code>IList[int, Any]</code> <p>The list of logical row indices.</p> required <p>Returns:</p> Name Type Description <code>Grid</code> <p>The grid corresponding to the specified block and column.</p> Source code in <code>src/bloqade/shuttle/stdlib/layouts/gemini/logical.py</code> <pre><code>@tweezer\ndef get_block(\n    block_id: str,\n    col_indices: ilist.IList[int, Any],\n    row_indices: ilist.IList[int, Any],\n):\n    \"\"\"Returns the zone corresponding to the specified block and column.\n\n    Args:\n        block_id (str): The block identifier, either \"GL\" or \"GR\".\n        col_indices (IList[int, Any]): The list of logical column indices.\n        row_indices (IList[int, Any]): The list of logical row indices.\n\n    Returns:\n        Grid: The grid corresponding to the specified block and column.\n\n    \"\"\"\n    assert block_id in (\"GL\", \"GR\"), \"block_id must be either 'GL' or 'GR'\"\n\n    block = None\n    if block_id == \"GL\":\n        block = spec.get_static_trap(zone_id=\"GL_blocks\")\n    elif block_id == \"GR\":\n        block = spec.get_static_trap(zone_id=\"GR_blocks\")\n\n    code_size = spec.get_int_constant(constant_id=\"code_size\")\n\n    def _get_physical_columns(logical_col: int):\n        return ilist.range(logical_col * code_size, (logical_col + 1) * code_size)\n\n    def join(\n        lhs: ilist.IList[int, Any], rhs: ilist.IList[int, Any]\n    ) -&gt; ilist.IList[int, Any]:\n        return lhs + rhs\n\n    physical_columns_lists = ilist.map(_get_physical_columns, col_indices)\n    physical_col_indices = ilist.foldl(\n        join, physical_columns_lists[1:], physical_columns_lists[0]\n    )\n\n    return block[physical_col_indices, row_indices]\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/#bloqade.shuttle.stdlib.layouts.gemini.logical.get_other_block","title":"get_other_block","text":"<pre><code>get_other_block(block_id: str) -&gt; str\n</code></pre> <p>Returns the identifier of the other block.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>str</code> <p>The current block identifier, either \"GL\" or \"GR\".</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The identifier of the other block.</p> Source code in <code>src/bloqade/shuttle/stdlib/layouts/gemini/logical.py</code> <pre><code>@tweezer\ndef get_other_block(block_id: str) -&gt; str:\n    \"\"\"Returns the identifier of the other block.\n\n    Args:\n        block_id (str): The current block identifier, either \"GL\" or \"GR\".\n\n    Returns:\n        str: The identifier of the other block.\n\n    \"\"\"\n    assert block_id in (\"GL\", \"GR\"), \"block_id must be either 'GL' or 'GR'\"\n    other_block = \"GL\"\n    if block_id == \"GL\":\n        other_block = \"GR\"\n    return other_block\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/#bloqade.shuttle.stdlib.layouts.gemini.logical.get_spec","title":"get_spec","text":"<pre><code>get_spec()\n</code></pre> <p>Get the architecture specification for the Gemini logical qubit layout.</p> <p>Returns:</p> Name Type Description <code>ArchSpec</code> <p>The architecture specification with Gemini logical qubit layout.</p> Source code in <code>src/bloqade/shuttle/stdlib/layouts/gemini/logical.py</code> <pre><code>def get_spec():\n    \"\"\"Get the architecture specification for the Gemini logical qubit layout.\n\n    Returns:\n        ArchSpec: The architecture specification with Gemini logical qubit layout.\n\n    \"\"\"\n    arch_spec = get_base_spec()\n\n    gate_zone = arch_spec.layout.static_traps[\"gate_zone\"]\n    aom_sites = arch_spec.layout.special_grid[\"aom_sites\"]\n    top_reservoir = arch_spec.layout.static_traps[\"top_reservoir\"]\n    bottom_reservoir = arch_spec.layout.static_traps[\"bottom_reservoir\"]\n\n    left_traps = gate_zone[::2, :]\n    right_traps = gate_zone[1::2, :]\n    S_block = top_reservoir[4 : 4 + 7 * 4, 8 : 8 + 5 * 2 : 2]\n    M_block = bottom_reservoir[4 : 4 + 7 * 4 :, 2 : 2 + 5 * 2 : 2]\n\n    S0_block = S_block[: 2 * 7, :]\n    S1_block = S_block[2 * 7 :, :]\n    M0_block = M_block[: 2 * 7, :]\n    M1_block = M_block[2 * 7 :, :]\n\n    SL0_block = S0_block[::2, :]\n    SR0_block = S0_block[1::2, :]\n\n    SL1_block = S1_block[::2, :]\n    SR1_block = S1_block[1::2, :]\n\n    ML0_block = M0_block[::2, :]\n    MR0_block = M0_block[1::2, :]\n    ML1_block = M1_block[::2, :]\n    MR1_block = M1_block[1::2, :]\n\n    GL_blocks = left_traps[2 : 2 + 2 * 7, :]\n    GR_blocks = right_traps[2 : 2 + 2 * 7, :]\n\n    GL0_block = GL_blocks[:7, :]\n    GR0_block = GR_blocks[:7, :]\n\n    GL1_block = GL_blocks[7 : 2 * 7, :]\n    GR1_block = GR_blocks[7 : 2 * 7, :]\n\n    AOM0_block = aom_sites[2 : 2 + 7, :]\n    AOM1_block = aom_sites[2 + 7 : 2 + 7 + 7, :]\n\n    additional_static_traps = {\n        \"left_gate_zone_sites\": left_traps,\n        \"right_gate_zone_sites\": right_traps,\n        \"top_reservoir_sites\": top_reservoir,\n        \"bottom_reservoir_sites\": bottom_reservoir,\n        \"GL_blocks\": GL_blocks,\n        \"GR_blocks\": GR_blocks,\n        \"GL0_block\": GL0_block,\n        \"GL1_block\": GL1_block,\n        \"GR0_block\": GR0_block,\n        \"GR1_block\": GR1_block,\n        \"SL0_block\": SL0_block,\n        \"SL1_block\": SL1_block,\n        \"SR0_block\": SR0_block,\n        \"SR1_block\": SR1_block,\n        \"ML0_block\": ML0_block,\n        \"ML1_block\": ML1_block,\n        \"MR0_block\": MR0_block,\n        \"MR1_block\": MR1_block,\n    }\n    additional_special_grids = {\n        \"AOM0_block\": AOM0_block,\n        \"AOM1_block\": AOM1_block,\n    }\n\n    arch_spec.layout.static_traps.update(additional_static_traps)\n    arch_spec.layout.special_grid.update(additional_special_grids)\n    arch_spec.layout.has_cz.add(\"gate_zone\")\n    arch_spec.layout.fillable.update((\"GL0_block\", \"GL1_block\"))\n    arch_spec.layout.has_local.update(\n        (\"GL0_block\", \"GL1_block\", \"GR0_block\", \"GR1_block\")\n    )\n\n    logical_rows, _ = SL0_block.shape\n    logical_cols = 2\n    code_size = 7\n\n    int_constants = {\n        \"logical_rows\": logical_rows,\n        \"logical_cols\": logical_cols,\n        \"code_size\": code_size,\n    }\n\n    arch_spec.int_constants.update(int_constants)\n\n    return arch_spec\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/#bloqade.shuttle.stdlib.layouts.gemini.logical.gl_entangle","title":"gl_entangle","text":"<pre><code>gl_entangle(\n    src_cols: IList[int, Nx],\n    src_rows: IList[int, Ny],\n    dst_cols: IList[int, Nx],\n    dst_rows: IList[int, Ny],\n)\n</code></pre> <p>Entangles the qubits located in the \"GL\" blocks between src and dst positions.</p> <p>The function performs the following steps: 1. Validates the input parameters to ensure they are sorted and of equal length. 3. Moves the qubits horizontally if the source and destination columns differ. 4. Moves the qubits vertically if the source and destination rows differ. 5. Applies a CZ gate to the qubits in the gate zone. 6. Reverses the vertical and horizontal moves to return the qubits to their original positions.</p> <p>Parameters:</p> Name Type Description Default <code>src_cols</code> <code>IList[int, Nx]</code> <p>The list of source column indices.</p> required <code>src_rows</code> <code>IList[int, Ny]</code> <p>The list of source row indices.</p> required <code>dst_cols</code> <code>IList[int, Nx]</code> <p>The list of destination column indices.</p> required <code>dst_rows</code> <code>IList[int, Ny]</code> <p>The list of destination row indices.</p> required Source code in <code>src/bloqade/shuttle/stdlib/layouts/gemini/logical.py</code> <pre><code>@move\ndef gl_entangle(\n    src_cols: ilist.IList[int, Nx],\n    src_rows: ilist.IList[int, Ny],\n    dst_cols: ilist.IList[int, Nx],\n    dst_rows: ilist.IList[int, Ny],\n):\n    \"\"\"Entangles the qubits located in the \"GL\" blocks between src and dst positions.\n\n    The function performs the following steps:\n    1. Validates the input parameters to ensure they are sorted and of equal length.\n    3. Moves the qubits horizontally if the source and destination columns differ.\n    4. Moves the qubits vertically if the source and destination rows differ.\n    5. Applies a CZ gate to the qubits in the gate zone.\n    6. Reverses the vertical and horizontal moves to return the qubits to their original positions.\n\n    Args:\n        src_cols (ilist.IList[int, Nx]): The list of source column indices.\n        src_rows (ilist.IList[int, Ny]): The list of source row indices.\n        dst_cols (ilist.IList[int, Nx]): The list of destination column indices.\n        dst_rows (ilist.IList[int, Ny]): The list of destination row indices.\n\n    \"\"\"\n\n    assert_sorted(src_cols)\n    assert_sorted(src_rows)\n    assert_sorted(dst_cols)\n    assert_sorted(dst_rows)\n\n    assert len(src_cols) == len(\n        dst_cols\n    ), \"src_cols and dst_cols must have the same length\"\n    assert len(src_rows) == len(\n        dst_rows\n    ), \"src_rows and dst_rows must have the same length\"\n\n    x_tones = ilist.range(\n        0, len(src_cols) * spec.get_int_constant(constant_id=\"code_size\")\n    )\n    y_tones = ilist.range(0, len(src_rows))\n\n    device_fn = schedule.device_fn(entangle_move_impl, x_tones, y_tones)\n    inf_device_fn = schedule.reverse(device_fn)\n\n    device_fn(\"GL\", src_cols, src_rows, dst_cols, dst_rows)\n    gate.top_hat_cz(spec.get_static_trap(zone_id=\"gate_zone\"))\n    inf_device_fn(\"GL\", dst_cols, dst_rows, src_cols, src_rows)\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/#bloqade.shuttle.stdlib.layouts.gemini.logical.horizontal_move_impl","title":"horizontal_move_impl","text":"<pre><code>horizontal_move_impl(\n    block_id: str,\n    row_indices: IList[int, Any],\n    src_cols: IList[int, N],\n    dst_cols: IList[int, N],\n)\n</code></pre> <p>Moves the specified columns within the given block.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>str</code> <p>The block identifier, either \"GL\" or \"GR\".</p> required <code>row_indices</code> <code>IList[int, Any]</code> <p>The list of row indices.</p> required <code>src_cols</code> <code>IList[int, N]</code> <p>The list of source column indices.</p> required <code>dst_cols</code> <code>IList[int, N]</code> <p>The list of destination column indices.</p> required Source code in <code>src/bloqade/shuttle/stdlib/layouts/gemini/logical.py</code> <pre><code>@tweezer\ndef horizontal_move_impl(\n    block_id: str,\n    row_indices: ilist.IList[int, Any],\n    src_cols: ilist.IList[int, N],\n    dst_cols: ilist.IList[int, N],\n):\n    \"\"\"Moves the specified columns within the given block.\n\n    Args:\n        block_id (str): The block identifier, either \"GL\" or \"GR\".\n        row_indices (ilist.IList[int, Any]): The list of row indices.\n        src_cols (ilist.IList[int, N]): The list of source column indices.\n        dst_cols (ilist.IList[int, N]): The list of destination column indices.\n    \"\"\"\n    assert_sorted(row_indices)\n    assert_sorted(src_cols)\n    assert_sorted(dst_cols)\n\n    assert len(src_cols) == len(\n        dst_cols\n    ), \"src_cols and dst_cols must have the same length\"\n\n    assert block_id in (\"GL\", \"GR\"), \"block_id must be either 'GL' or 'GR'\"\n    src = get_block(block_id, src_cols, row_indices)\n    dst = get_block(block_id, dst_cols, row_indices)\n    y_shift = spec.get_float_constant(constant_id=\"row_separation\") / 2.0\n\n    action.set_loc(src)\n    action.turn_on(action.ALL, action.ALL)\n    action.move(grid.shift(src, 0.0, y_shift))\n    action.move(grid.shift(dst, 0.0, y_shift))\n    action.move(dst)\n    action.turn_off(action.ALL, action.ALL)\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/#bloqade.shuttle.stdlib.layouts.gemini.logical.swap_block_impl","title":"swap_block_impl","text":"<pre><code>swap_block_impl(\n    src_block: str,\n    selected_cols: IList[int, Any],\n    selected_rows: IList[int, Any],\n)\n</code></pre> <p>Swaps the specified rows and columns between the source and destination blocks.</p> <p>Parameters:</p> Name Type Description Default <code>src_block</code> <code>str</code> <p>the current block identifier, either \"GL\" or \"GR\".</p> required <code>selected_cols</code> <code>IList[int, Any]</code> <p>the list of selected column indices to swap.</p> required <code>selected_rows</code> <code>IList[int, Any]</code> <p>the list of selected row indices to swap.</p> required Source code in <code>src/bloqade/shuttle/stdlib/layouts/gemini/logical.py</code> <pre><code>@tweezer\ndef swap_block_impl(\n    src_block: str,\n    selected_cols: ilist.IList[int, Any],\n    selected_rows: ilist.IList[int, Any],\n):\n    \"\"\"Swaps the specified rows and columns between the source and destination blocks.\n\n    Args:\n        src_block (str): the current block identifier, either \"GL\" or \"GR\".\n        selected_cols (ilist.IList[int, Any]): the list of selected column indices to swap.\n        selected_rows (ilist.IList[int, Any]): the list of selected row indices to swap.\n    \"\"\"\n\n    assert_sorted(selected_cols)\n    assert_sorted(selected_rows)\n\n    dst_block = get_other_block(src_block)\n\n    start = get_block(src_block, selected_cols, selected_rows)\n    end = get_block(dst_block, selected_cols, selected_rows)\n\n    action.set_loc(start)\n    action.turn_on(action.ALL, action.ALL)\n    action.move(end)\n    action.turn_off(action.ALL, action.ALL)\n</code></pre>"},{"location":"reference/bloqade/shuttle/stdlib/layouts/gemini/logical/#bloqade.shuttle.stdlib.layouts.gemini.logical.vertical_move_impl","title":"vertical_move_impl","text":"<pre><code>vertical_move_impl(\n    block_id: str,\n    col_indices: IList[int, Any],\n    src_rows: IList[int, N],\n    dst_rows: IList[int, N],\n)\n</code></pre> <p>Moves the specified rows within the given block.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>str</code> <p>The block identifier, either \"GL\" or \"GR\".</p> required <code>col_indices</code> <code>IList[int, Any]</code> <p>The list of logical column indices.</p> required <code>src_rows</code> <code>IList[int, N]</code> <p>The list of source row indices.</p> required <code>dst_rows</code> <code>IList[int, N]</code> <p>The list of destination row indices.</p> required Source code in <code>src/bloqade/shuttle/stdlib/layouts/gemini/logical.py</code> <pre><code>@tweezer\ndef vertical_move_impl(\n    block_id: str,\n    col_indices: ilist.IList[int, Any],\n    src_rows: ilist.IList[int, N],\n    dst_rows: ilist.IList[int, N],\n):\n    \"\"\"Moves the specified rows within the given block.\n\n    Args:\n        block_id (str): The block identifier, either \"GL\" or \"GR\".\n        col_indices (ilist.IList[int, Any]): The list of logical column indices.\n        src_rows (ilist.IList[int, N]): The list of source row indices.\n        dst_rows (ilist.IList[int, N]): The list of destination row indices.\n\n    \"\"\"\n    assert_sorted(col_indices)\n    assert_sorted(src_rows)\n    assert_sorted(dst_rows)\n\n    assert len(src_rows) == len(\n        dst_rows\n    ), \"src_rows and dst_rows must have the same length\"\n\n    assert block_id in (\"GL\", \"GR\"), \"block_id must be either 'GL' or 'GR'\"\n    src = get_block(block_id, col_indices, src_rows)\n    dst = get_block(block_id, col_indices, dst_rows)\n\n    x_shift = spec.get_float_constant(constant_id=\"col_separation\") / 2.0\n    if block_id == \"GL\":\n        x_shift = -x_shift\n\n    action.set_loc(src)\n    action.turn_on(action.ALL, action.ALL)\n    action.move(grid.shift(src, x_shift, 0.0))\n    action.move(grid.shift(dst, x_shift, 0.0))\n    action.move(dst)\n    action.turn_off(action.ALL, action.ALL)\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/visualizer/interp/","title":"Interp","text":""},{"location":"reference/bloqade/shuttle/visualizer/interp/#bloqade.shuttle.visualizer.interp.PathVisualizer","title":"PathVisualizer  <code>dataclass</code>","text":"<pre><code>PathVisualizer(\n    arch_spec: ArchSpec,\n    *,\n    renderer: Plotter = default_renderer()\n)\n</code></pre> <p>               Bases: <code>ArchSpecInterpreter</code>, <code>Generic[Plotter]</code></p> <p>Debugging interpreter for visualizing the execution of paths.</p>"},{"location":"reference/bloqade/shuttle/visualizer/impl/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/visualizer/impl/gate/","title":"Gate","text":""},{"location":"reference/bloqade/shuttle/visualizer/impl/init/","title":"Init","text":""},{"location":"reference/bloqade/shuttle/visualizer/impl/measure/","title":"Measure","text":""},{"location":"reference/bloqade/shuttle/visualizer/impl/path/","title":"Path","text":""},{"location":"reference/bloqade/shuttle/visualizer/renderers/","title":"Index","text":""},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/","title":"Interface","text":""},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface","title":"RendererInterface","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.clear_paths","title":"clear_paths  <code>abstractmethod</code>","text":"<pre><code>clear_paths() -&gt; None\n</code></pre> <p>Clear the current renderer.</p> Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>@abstractmethod\ndef clear_paths(self) -&gt; None:\n    \"\"\"Clear the current renderer.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.global_r","title":"global_r","text":"<pre><code>global_r() -&gt; None\n</code></pre> <p>Render the global render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>def global_r(self) -&gt; None:\n    \"\"\"Render the global render of the given location.\n\n    Args:\n        location (grid.Grid): The location to render.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.global_rz","title":"global_rz","text":"<pre><code>global_rz() -&gt; None\n</code></pre> <p>Render the global render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>def global_rz(self) -&gt; None:\n    \"\"\"Render the global render of the given location.\n\n    Args:\n        location (grid.Grid): The location to render.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.local_r","title":"local_r","text":"<pre><code>local_r(location: Grid) -&gt; None\n</code></pre> <p>Render the local render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>def local_r(self, location: grid.Grid) -&gt; None:\n    \"\"\"Render the local render of the given location.\n\n    Args:\n        location (grid.Grid): The location to render.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.local_rz","title":"local_rz","text":"<pre><code>local_rz(location: Grid) -&gt; None\n</code></pre> <p>Render the local render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>def local_rz(self, location: grid.Grid) -&gt; None:\n    \"\"\"Render the local render of the given location.\n\n    Args:\n        location (grid.Grid): The location to render.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.render_path","title":"render_path  <code>abstractmethod</code>","text":"<pre><code>render_path(pth: Path) -&gt; None\n</code></pre> <p>Render the given path.</p> <p>Parameters:</p> Name Type Description Default <code>pth</code> <code>Path</code> <p>The path to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>@abstractmethod\ndef render_path(self, pth: path.Path) -&gt; None:\n    \"\"\"Render the given path.\n\n    Args:\n        pth (path.Path): The path to render.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.render_traps","title":"render_traps  <code>abstractmethod</code>","text":"<pre><code>render_traps(traps: Grid, zone_id: str) -&gt; None\n</code></pre> <p>Render the given traps.</p> <p>Parameters:</p> Name Type Description Default <code>traps</code> <code>IList[Grid, Any]</code> <p>The traps to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>@abstractmethod\ndef render_traps(self, traps: grid.Grid, zone_id: str) -&gt; None:\n    \"\"\"Render the given traps.\n\n    Args:\n        traps (ilist.IList[grid.Grid, Any]): The traps to render.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.set_title","title":"set_title  <code>abstractmethod</code>","text":"<pre><code>set_title(title: str) -&gt; None\n</code></pre> <p>Set the title of the renderer.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title to set.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>@abstractmethod\ndef set_title(self, title: str) -&gt; None:\n    \"\"\"Set the title of the renderer.\n\n    Args:\n        title (str): The title to set.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.show","title":"show  <code>abstractmethod</code>","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show all rendered entities.</p> Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>@abstractmethod\ndef show(self) -&gt; None:\n    \"\"\"Show all rendered entities.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/interface/#bloqade.shuttle.visualizer.renderers.interface.RendererInterface.top_hat_cz","title":"top_hat_cz","text":"<pre><code>top_hat_cz(\n    location: Grid, upper_buffer: float, lower_buffer: float\n) -&gt; None\n</code></pre> <p>Render the top hat CZ of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/interface.py</code> <pre><code>def top_hat_cz(\n    self, location: grid.Grid, upper_buffer: float, lower_buffer: float\n) -&gt; None:\n    \"\"\"Render the top hat CZ of the given location.\n\n    Args:\n        location (grid.Grid): The location to render.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/","title":"Matplotlib","text":""},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer","title":"MatplotlibRenderer  <code>dataclass</code>","text":"<pre><code>MatplotlibRenderer(\n    ax: Axes = default_ax(),\n    gate_display_options: GateDisplayOptions = GateDisplayOptions(),\n    *,\n    arrow_rescale: float = 1.0,\n    sleep_time: float = 0.1\n)\n</code></pre> <p>               Bases: <code>RendererInterface</code></p>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.clear_paths","title":"clear_paths","text":"<pre><code>clear_paths() -&gt; None\n</code></pre> <p>Clear the current renderer.</p> Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def clear_paths(self) -&gt; None:\n    while self.curr_path_lines:\n        artist = self.curr_path_lines.pop()\n        artist.remove()\n\n    self.ax.set_title(\"\")\n    plt.show(block=False)\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.global_r","title":"global_r","text":"<pre><code>global_r() -&gt; None\n</code></pre> <p>Render the global render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def global_r(self) -&gt; None:\n    x = [self.xmin - 10, self.xmax + 10]\n    y = [self.ymin - 10, self.ymax + 10]\n\n    line = self.ax.fill_between(\n        x,\n        y[0],\n        y[1],\n        color=self.gate_display_options.r_color,\n        alpha=self.gate_display_options.alpha,\n    )\n    self.show()\n    line.remove()\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.global_rz","title":"global_rz","text":"<pre><code>global_rz() -&gt; None\n</code></pre> <p>Render the global render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def global_rz(self) -&gt; None:\n    x = [self.xmin - 10, self.xmax + 10]\n    y = [self.ymin - 10, self.ymax + 10]\n\n    line = self.ax.fill_between(\n        x,\n        y[0],\n        y[1],\n        color=self.gate_display_options.rz_color,\n        alpha=self.gate_display_options.alpha / 2,\n    )\n\n    self.show()\n    line.remove()\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.local_r","title":"local_r","text":"<pre><code>local_r(location: Grid) -&gt; None\n</code></pre> <p>Render the local render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def local_r(self, location: Grid) -&gt; None:\n    x, y = np.meshgrid(location.x_positions, location.y_positions)\n\n    (points,) = self.ax.plot(\n        x.flatten(),\n        y.flatten(),\n        marker=\"o\",\n        markersize=self.gate_display_options.local_spot_size,\n        linestyle=\"\",\n        color=self.gate_display_options.r_color,\n        alpha=self.gate_display_options.alpha,\n    )\n\n    self.show()\n    points.remove()\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.local_rz","title":"local_rz","text":"<pre><code>local_rz(location: Grid) -&gt; None\n</code></pre> <p>Render the local render of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def local_rz(self, location: Grid) -&gt; None:\n    x, y = np.meshgrid(location.x_positions, location.y_positions)\n\n    (points,) = self.ax.plot(\n        x.flatten(),\n        y.flatten(),\n        marker=\"o\",\n        markersize=self.gate_display_options.local_spot_size,\n        linestyle=\"\",\n        color=self.gate_display_options.rz_color,\n        alpha=self.gate_display_options.alpha,\n    )\n\n    self.show()\n    points.remove()\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.render_path","title":"render_path","text":"<pre><code>render_path(pth: Path) -&gt; None\n</code></pre> <p>Render the given path.</p> <p>Parameters:</p> Name Type Description Default <code>pth</code> <code>Path</code> <p>The path to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def render_path(self, pth: path.Path) -&gt; None:\n    all_waypoints = [\n        way_point\n        for path_action in pth.path\n        if isinstance(path_action, taskgen.WayPointsAction)\n        for way_point in path_action.way_points\n    ]\n\n    num_unique_waypoints = len(set(all_waypoints))\n    if num_unique_waypoints &lt; 2:\n        return\n\n    num_arrows = num_unique_waypoints - 1\n    first_waypoint = all_waypoints[0]\n    curr_x = first_waypoint.x_positions\n    curr_y = first_waypoint.y_positions\n\n    color_map = plt.get_cmap(\"viridis\")\n\n    step = 0\n\n    x_tones = np.array(pth.x_tones)\n    y_tones = np.array(pth.y_tones)\n\n    x = all_waypoints[0].x_positions\n    y = all_waypoints[0].y_positions\n    self.clear_paths()\n    self.show()\n\n    for action in pth.path:\n        if isinstance(action, taskgen.WayPointsAction):\n            for start, end in zip(action.way_points[:-1], action.way_points[1:]):\n                x = end.x_positions\n                y = end.y_positions\n                curr_x = start.x_positions\n                curr_y = start.y_positions\n\n                for (x_tone, x_start, x_end), (y_tone, y_start, y_end) in product(\n                    zip(pth.x_tones, curr_x, x), zip(pth.y_tones, curr_y, y)\n                ):\n                    self.update_x_bounds(x_start)\n                    self.update_x_bounds(x_end)\n                    self.update_y_bounds(y_start)\n                    self.update_y_bounds(y_end)\n                    dx = x_end - x_start\n                    dy = y_end - y_start\n\n                    if dx == 0 and dy == 0:\n                        continue\n\n                    is_on = (\n                        x_tone in self.active_x_tones\n                        and y_tone in self.active_y_tones\n                    )\n                    p = step / (num_arrows - 1) if num_arrows &gt; 1 else 0.0\n                    line = self.ax.arrow(\n                        x_start,\n                        y_start,\n                        dx,\n                        dy,\n                        width=self.arrow_scale,\n                        color=color_map(p),\n                        length_includes_head=True,\n                        linestyle=\"-\" if is_on else (0, (5, 10)),\n                        alpha=1.0 if is_on else 0.5,\n                        linewidth=1.0 if is_on else 0.5,\n                    )\n\n                    line.set_edgecolor(line.get_facecolor())\n                    self.curr_path_lines.append(line)\n\n                if curr_x != x or curr_y != y:\n                    step += 1\n                    self.show()\n\n        elif isinstance(action, taskgen.TurnOnAction):\n            self.active_x_tones.update(x_tones[action.x_tone_indices])\n            self.active_y_tones.update(y_tones[action.y_tone_indices])\n\n        elif isinstance(action, taskgen.TurnOffAction):\n            self.active_x_tones.difference_update(x_tones[action.x_tone_indices])\n            self.active_y_tones.difference_update(y_tones[action.y_tone_indices])\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.render_traps","title":"render_traps","text":"<pre><code>render_traps(traps: Grid, zone_id: str) -&gt; None\n</code></pre> <p>Render the given traps.</p> <p>Parameters:</p> Name Type Description Default <code>traps</code> <code>IList[Grid, Any]</code> <p>The traps to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def render_traps(self, traps: Grid, zone_id: str) -&gt; None:\n    x, y = np.meshgrid(traps.x_positions, traps.y_positions)\n\n    self.ax.plot(x.flatten(), y.flatten(), marker=\"o\", markersize=3, linestyle=\"\")\n    self.update_x_bounds(traps.x_positions[0])\n    self.update_x_bounds(traps.x_positions[-1])\n    self.update_y_bounds(traps.y_positions[0])\n    self.update_y_bounds(traps.y_positions[-1])\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.set_title","title":"set_title","text":"<pre><code>set_title(title: str) -&gt; None\n</code></pre> <p>Set the title of the renderer.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title to set.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def set_title(self, title: str) -&gt; None:\n    self.ax.set_title(title)\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show all rendered entities.</p> Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def show(self) -&gt; None:\n    plt.show(block=False)\n    self.continue_button.on_clicked(lambda event: setattr(self, \"sleeping\", False))\n\n    self.sleeping = True\n    while self.sleeping:\n        plt.pause(self.sleep_time)\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.MatplotlibRenderer.top_hat_cz","title":"top_hat_cz","text":"<pre><code>top_hat_cz(\n    location: Grid, upper_buffer: float, lower_buffer: float\n) -&gt; None\n</code></pre> <p>Render the top hat CZ of the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Grid</code> <p>The location to render.</p> required Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def top_hat_cz(\n    self, location: Grid, upper_buffer: float, lower_buffer: float\n) -&gt; None:\n    ymin, ymax = location.y_bounds()\n\n    assert ymin is not None and ymax is not None, \"Y bounds must be defined\"\n    ymin = ymin - lower_buffer\n    ymax = ymax + upper_buffer\n    ymin_keepout = ymin - 3\n    ymax_keepout = ymax + 3\n    x = [self.xmin - 10, self.xmax + 10]\n    inner = self.ax.fill_between(\n        x,\n        ymin,\n        ymax,\n        color=self.gate_display_options.rydberg_color,\n        alpha=self.gate_display_options.alpha,\n    )\n    outer = self.ax.fill_between(\n        x,\n        ymin_keepout,\n        ymax_keepout,\n        color=self.gate_display_options.rydberg_color,\n        alpha=self.gate_display_options.alpha / 2,\n    )\n\n    self.show()\n    inner.remove()\n    outer.remove()\n</code></pre>"},{"location":"reference/bloqade/shuttle/visualizer/renderers/matplotlib/#bloqade.shuttle.visualizer.renderers.matplotlib.default_ax","title":"default_ax","text":"<pre><code>default_ax() -&gt; Axes\n</code></pre> <p>Create a default matplotlib Axes object.</p> Source code in <code>src/bloqade/shuttle/visualizer/renderers/matplotlib.py</code> <pre><code>def default_ax() -&gt; Axes:\n    \"\"\"Create a default matplotlib Axes object.\"\"\"\n    _, ax = plt.subplots(1, 1)\n    ax.set_aspect(\"equal\", adjustable=\"box\")\n    ax.set_xlabel(\"X (um)\")\n    ax.set_ylabel(\"Y (um)\")\n    return ax\n</code></pre>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/tutorial/","title":"Tutorial","text":""}]}